{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<p>Introduction</p>","text":"<p>Telebof is a modern Java wrapper for the Telegram Bot API, designed to make building bots fast, simple, and intuitive. Whether you want to create a lightweight utility bot or a fully featured automation system, Telebof provides a clean interface to handle commands, inline buttons, payment updates, and more.  </p> <pre><code>import io.github.natanimn.BotClient;\n\npublic class MyFirstBot {\n  static final String TOKEN = \"YOUR_BOT_TOKEN_HERE\";\n\n  public static void main(String[] args) {\n    final BotClient bot = new BotClient(TOKEN);\n\n    bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n        context.sendMessage(message.getChat().getId(), \"Welcome!\").exec();\n    });\n\n    bot.onMessage(filter -&gt; filter.text(), (context, message) -&gt; {\n        context.sendMessage(message.getChat().getId(), message.getText()).exec();\n    });\n\n    bot.startPolling();\n  }\n}\n</code></pre>"},{"location":"#join-our-community","title":"Join Our Community","text":"<ul> <li>\ud83d\udce2 Telegram News Channel</li> <li>\ud83d\udc65 Telegram Group Chat</li> </ul>"},{"location":"#prerequesites","title":"Prerequesites","text":"<p>Before diving in, make sure you have:  </p> <ul> <li>Java 20 or above.  </li> <li>Basic understanding of Java.</li> <li>Knowledge of Telegram Bot API </li> </ul>"},{"location":"#users-guide","title":"User's Guide","text":"<ul> <li>Installation</li> <li>Handling Updates</li> <li>Annotations</li> <li>Filters</li> <li>Using States</li> <li>Advanced Features</li> <li>Error Handling</li> <li>Example Bots</li> <li>Full API Reference</li> </ul>"},{"location":"advance/","title":"Advanced Features in Telebof","text":"<p>Telebof provides several advanced configuration options to customize your bot's behavior, including proxy support, logging control, multi-threading, and update management.</p>"},{"location":"advance/#custom-proxy-configuration","title":"Custom Proxy Configuration","text":"<p>Telebof allows you to route bot traffic through a proxy server, which is useful for bypassing network restrictions or enhancing privacy.</p> <p>Example: Setting up a SOCKS proxy</p> <pre><code>import io.github.natanimn.telebof.BotClient;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\n\npublic class ProxyExample {\n    public static void main(String[] args) {\n        // Create socket address with proxy server details\n        InetSocketAddress address = new InetSocketAddress(\"127.97.91\", 80); // hostname and port\n\n        // Create SOCKS proxy instance\n        Proxy proxy = new Proxy(Proxy.Type.SOCKS, address);\n\n        // Configure bot with proxy settings\n        BotClient bot = new BotClient.Builder(TOKEN)\n                .proxy(proxy)\n                .build();\n    }\n}\n</code></pre> <p>Supported Proxy Types:</p> <ul> <li><code>Proxy.Type.SOCKS</code> - SOCKS proxy (versions 4/5)</li> <li><code>Proxy.Type.HTTP</code> - HTTP proxy</li> <li><code>Proxy.Type.DIRECT</code> - No proxy (default)</li> </ul>"},{"location":"advance/#logging-configuration","title":"Logging Configuration","text":"<p>Telebof uses Java's built-in logging framework, allowing you to control log levels for debugging and monitoring.</p> <p>Example: Setting log levels</p> <pre><code>import io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.log.BotLog;\nimport java.util.logging.Level;\n\npublic class LoggingExample {\n    public static void main(String[] args) {\n        // Set different log levels as needed\n        BotLog.setLevel(Level.INFO); // Options: SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST\n\n        BotClient bot = new BotClient(TOKEN);\n\n        // Example of different log levels in practice:\n        // - SEVERE: Critical errors that prevent operation\n        // - WARNING: Potential issues that don't stop execution (default)\n        // - INFO: General operational information\n        // - FINE: Detailed debugging information\n    }\n}\n</code></pre> <p>Default Log Level: <code>Level.WARNING</code> (shows only warnings and errors)</p>"},{"location":"advance/#multi-threading-configuration","title":"Multi-Threading Configuration","text":"<p>Telebof supports concurrent update processing through configurable threading, improving performance for high traffic bots.</p> <p>Example: Configuring multiple threads</p> <pre><code>public class ThreadingExample {\n    public static void main(String[] args) {\n        // Configure bot with 10 threads for concurrent processing\n        var bot = new BotClient.Builder(TOKEN)\n                .numThreads(10) // Process updates in parallel\n                .build();\n    }\n}\n</code></pre> <p>Default: 2 threads Recommendation: Adjust based on your server's CPU cores and expected message volume</p>"},{"location":"advance/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's how to use all advanced features together in a single configuration:</p> <pre><code>import io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.log.BotLog;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.enums.Updates;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.util.logging.Level;\n\npublic class AdvancedConfigurationExample {\n    public static void main(String[] args) {\n        // Configure logging first\n        BotLog.setLevel(Level.INFO); // Set to INFO level for operational details\n\n        // Set up proxy (optional)\n        InetSocketAddress proxyAddress = new InetSocketAddress(\"proxy.example.com\", 8080);\n        Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyAddress);\n\n        // Complete bot configuration with all advanced options\n        BotClient bot = new BotClient.Builder(TOKEN)\n                .skipOldUpdates(false)       // Receive updates from last 24 hours\n                .limit(10)                   // Maximum 10 updates per request\n                .useTestServer(false)        // Use production Telegram server\n                .timeout(30)                 // 30-second timeout for requests\n                .offset(-1)                  // Start from most recent update\n                .allowedUpdates(Updates.ALL) // Receive all update types\n                .proxy(proxy)                // Use HTTP proxy\n                .numThreads(4)               // Use 4 threads for processing\n                .localBotApiUrl(\"https://your-local-bot-api.com\") // Custom Bot API server\n                .build();\n    }\n}\n</code></pre>"},{"location":"advance/#configuration-options-explained","title":"Configuration Options Explained","text":""},{"location":"advance/#skipoldupdatesfalse","title":"<code>skipOldUpdates(false)</code>","text":"<ul> <li>Purpose: Controls whether to receive updates sent while the bot was offline</li> <li><code>false</code>: Receive updates from the last 24 hours (catch up on missed messages)</li> <li><code>true</code>: Skip old updates and only process new ones</li> </ul>"},{"location":"advance/#limit10","title":"<code>limit(10)</code>","text":"<ul> <li>Purpose: Limits the number of updates retrieved per polling request</li> <li>Default: Usually 100 (Telegram's default)</li> <li>Use Case: Reduce memory usage or network traffic</li> </ul>"},{"location":"advance/#usetestserverfalse","title":"<code>useTestServer(false)</code>","text":"<ul> <li>Purpose: Switch between production and test environments</li> <li><code>false</code>: Use official Telegram Bot API (production)</li> <li><code>true</code>: Use test environment (Requires speciail bot token. Sign in using Telegram Web)</li> </ul>"},{"location":"advance/#timeout30","title":"<code>timeout(30)</code>","text":"<ul> <li>Purpose: Sets the HTTP request timeout in seconds</li> <li>Default: Varies by implementation</li> <li>Consideration: Increase for slow networks, decrease for faster response times</li> </ul>"},{"location":"advance/#offset-1","title":"<code>offset(-1)</code>","text":"<ul> <li>Purpose: Controls which updates to start receiving from</li> <li><code>-1</code>: Start from the most recent update</li> <li>Positive number: Start from a specific update ID</li> </ul>"},{"location":"advance/#allowedupdatesupdatesall","title":"<code>allowedUpdates(Updates.ALL)</code>","text":"<ul> <li>Purpose: Filters which types of updates to receive</li> </ul> <p>Options: </p> <ul> <li><code>Updates.ALL</code> - All update types</li> <li><code>Updates.MESSAGE</code> - Only messages</li> <li><code>Updates.CALLBACK_QUERY</code> - Only callback queries</li> <li><code>Updates.INLINE_QUERY</code> - Only inline queries</li> <li>(Other specific update types)</li> </ul>"},{"location":"advance/#proxyproxy","title":"<code>proxy(proxy)</code>","text":"<ul> <li>Purpose: Configures network proxy for all bot communications</li> <li>Use Cases: Network restrictions, security, privacy</li> </ul>"},{"location":"advance/#numthreads4","title":"<code>numThreads(4)</code>","text":"<ul> <li>Purpose: Sets the number of threads for concurrent update processing</li> <li>Default: 2 threads</li> <li>Optimization: Match to your server's CPU core count</li> </ul>"},{"location":"advance/#localbotapiurlurl","title":"<code>localBotApiUrl(url)</code>","text":"<ul> <li>Purpose: Run on your server</li> <li>Default: Telegram Server</li> <li>Read More: Using local bot api server</li> </ul>"},{"location":"annotations/","title":"Annotations","text":"<p>Telebof provides a comprehensive set of annotations for declarative handling of Telegram Bot API updates.  These annotations offer a clean, type-safe alternative to programmatic handler registration, making your bot code more maintainable and readable.</p>"},{"location":"annotations/#annotation-types","title":"Annotation Types","text":"<p>All annotations are defined in <code>io.github.natanimn.telebof.annotations</code></p>"},{"location":"annotations/#messagehandler","title":"@MessageHandler","text":"<p>Handles incoming messages from users or groups with comprehensive filtering options.</p> <p>Parameters:</p> <ul> <li><code>commands()</code> - Array of bot commands to match</li> <li><code>texts()</code> - Array of exact text content to match</li> <li><code>chatType()</code> - Array of chat types to filter by</li> <li><code>regex()</code> - Regular expression pattern for text matching</li> <li><code>type()</code> - Array of message types to filter by</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>state()</code> - Required conversation state</li> <li><code>priority()</code> - Execution priority (lower = earlier)</li> </ul>"},{"location":"annotations/#editedmessagehandler","title":"@EditedMessageHandler","text":"<p>Handles edited messages across various chat types with the same filtering capabilities as @MessageHandler.</p> <p>Parameters: Same as @MessageHandler</p>"},{"location":"annotations/#channelposthandler","title":"@ChannelPostHandler","text":"<p>Handles incoming channel posts with filtering options tailored for channel content.</p> <p>Parameters:</p> <ul> <li><code>commands()</code> - Array of bot commands to match</li> <li><code>texts()</code> - Array of exact text content to match</li> <li><code>regex()</code> - Regular expression pattern for text matching</li> <li><code>type()</code> - Array of message types to filter by</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#editedchannelposthandler","title":"@EditedChannelPostHandler","text":"<p>Handles edited channel posts with comprehensive filtering options.</p> <p>Parameters: Same as @ChannelPostHandler</p>"},{"location":"annotations/#businessmessagehandler","title":"@BusinessMessageHandler","text":"<p>Handles business message events with comprehensive filtering options tailored for Telegram Business accounts.</p> <p>Parameters: Same as @MessageHandler</p>"},{"location":"annotations/#editedbusinessmessagehandler","title":"@EditedBusinessMessageHandler","text":"<p>Handles edited business message events with the same comprehensive filtering capabilities.</p> <p>Parameters: Same as @MessageHandler</p>"},{"location":"annotations/#deletedbusinessmessagehandler","title":"@DeletedBusinessMessageHandler","text":"<p>Handles deleted business message events, particularly useful for audit logging and compliance.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#callbackhandler","title":"@CallbackHandler","text":"<p>Handles incoming callback queries from inline keyboards.</p> <p>Parameters:</p> <ul> <li><code>data()</code> - Array of callback data values to match</li> <li><code>chatType()</code> - Array of chat types to filter by</li> <li><code>regex()</code> - Regular expression pattern for callback data</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>state()</code> - Required conversation state</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#inlinehandler","title":"@InlineHandler","text":"<p>Handles inline query events with filtering options for query content and chat types.</p> <p>Parameters:</p> <p>-<code>query()</code> - Array of query text to match - <code>chatType()</code> - Array of chat types to filter by - <code>regex()</code> - Regular expression pattern for query matching - <code>filter()</code> - Custom filter class for advanced logic - <code>priority()</code> - Execution priority</p>"},{"location":"annotations/#choseninlinehandler","title":"@ChosenInlineHandler","text":"<p>Handles chosen inline result events when users select results from inline queries.</p> <p>Parameters:</p> <ul> <li><code>resultId()</code> - Array of result IDs to match</li> <li><code>query()</code> - Array of original query text to match</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#chatmemberhandler","title":"@ChatMemberHandler","text":"<p>Handles chat member status updates for user role changes.</p> <p>Parameters:</p> <ul> <li><code>status()</code> - Array of chat member status changes to match</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#mychatmemberhandler","title":"@MyChatMemberHandler","text":"<p>Handles the bot's own chat member status updates.</p> <p>Parameters:</p> <ul> <li><code>status()</code> - Array of status changes to match for the bot</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#chatjoinrequesthandler","title":"@ChatJoinRequestHandler","text":"<p>Handles chat join request events for private groups or channels requiring approval.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#precheckouthandler","title":"@PreCheckoutHandler","text":"<p>Handles pre-checkout query events for payment validation.</p> <p>Parameters:</p> <ul> <li><code>payload()</code> - Array of payment payload identifiers to match</li> <li><code>regex()</code> - Regular expression pattern for payload matching</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#shippinghandler","title":"@ShippingHandler","text":"<p>Handles shipping query events during checkout processes.</p> <p>Parameters:</p> <ul> <li><code>payload()</code> - Array of shipping query payload identifiers to match</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#purchasedpaidmediahandler","title":"@PurchasedPaidMediaHandler","text":"<p>Handles purchased paid media events for content delivery.</p> <p>Parameters:</p> <ul> <li><code>payload()</code> - Array of media purchase payload identifiers to match</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#reaction-and-engagement-annotations","title":"Reaction and Engagement Annotations","text":""},{"location":"annotations/#reactionhandler","title":"@ReactionHandler","text":"<p>Handles message reaction events when users add or remove reactions.</p> <p>Parameters:</p> <ul> <li><code>reaction()</code> - Specific reaction emoji to match</li> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#reactioncounthandler","title":"@ReactionCountHandler","text":"<p>Handles reaction count update events for monitoring engagement.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#boost-and-community-annotations","title":"Boost and Community Annotations","text":""},{"location":"annotations/#chatboosthandler","title":"@ChatBoostHandler","text":"<p>Handles chat boost events for supergroup upgrades and premium features.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#removedchatboosthandler","title":"@RemovedChatBoostHandler","text":"<p>Handles removed chat boost events for monitoring community support patterns.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#pollhandler","title":"@PollHandler","text":"<p>Handles poll state update events for monitoring poll lifecycle and results.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#pollanswerhandler","title":"@PollAnswerHandler","text":"<p>Handles poll answer events for processing user responses and voting patterns.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#businessconnectionhandler","title":"@BusinessConnectionHandler","text":"<p>Handles business connection events for monitoring account connections and authorization.</p> <p>Parameters:</p> <ul> <li><code>filter()</code> - Custom filter class for advanced logic</li> <li><code>priority()</code> - Execution priority</li> </ul>"},{"location":"annotations/#usage-examples","title":"Usage Examples","text":""},{"location":"annotations/#basic-message-handler","title":"Basic Message Handler","text":"<pre><code>@MessageHandler(commands = \"start\", chatType = ChatType.PRIVATE)\nvoid handleStartCommand(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Welcome!\").exec();\n}\n</code></pre>"},{"location":"annotations/#advanced-filtering-with-custom-logic","title":"Advanced Filtering with Custom Logic","text":"<pre><code>@MessageHandler(\n    commands = {\"help\", \"support\"},\n    chatType = ChatType.PRIVATE,\n    filter = PremiumUserFilter.class,\n    state = \"awaiting_support\"\n)\nvoid premiumSupport(BotContext context, Message message) {\n    // Handle premium support requests\n}\n</code></pre>"},{"location":"annotations/#multiple-handlers-with-priorities","title":"Multiple Handlers with Priorities","text":"<pre><code>@MessageHandler(commands = \"stats\")\nvoid showStats(BotContext context, Message message) {\n    // handle stats command\n}\n\n@MessageHandler(priority = 1)\nvoid logMessage(BotContext context, Message message) {\n    // Log all messages except /stats command\n}\n</code></pre>"},{"location":"annotations/#common-patterns","title":"Common Patterns","text":""},{"location":"annotations/#repeatable-annotations","title":"Repeatable Annotations","text":"<p>All handler annotations are <code>@Repeatable</code>, allowing multiple handlers on the same method:</p> <pre><code>@MessageHandler(commands = \"start\", type = ChatType.PRIVATE)\n@MessageHandler(commands = \"help\")\nvoid handleStartAndHelp(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Welcome to help!\").exec();\n}\n</code></pre>"},{"location":"annotations/#custom-filter-implementation","title":"Custom Filter Implementation","text":"<pre><code>public class PremiumUserFilter implements CustomFilter {\n    @Override\n    public boolean check(Update update) {\n        return update.getMessage().getFrom().getIsPremium() != null;\n    }\n}\n</code></pre> <p>Finally, you must add the class you registered handler in by using <code>addHandler</code> method <pre><code>bot.addHandler(new MyHandler())\n</code></pre></p>"},{"location":"annotations/#priority-system","title":"Priority System","text":"<ul> <li>Lower priority numbers execute before higher numbers</li> <li>Negative values are allowed and execute even earlier</li> <li>Default priority is 0</li> <li>Useful for controlling execution order when multiple handlers match the same update with the same content</li> </ul>"},{"location":"annotations/#the-critical-importance-of-priority-in-handler-execution","title":"The Critical Importance of Priority in Handler Execution","text":""},{"location":"annotations/#the-fundamental-problem-jvm-method-ordering","title":"The Fundamental Problem: JVM Method Ordering","text":"<p>Java's <code>getDeclaredMethods()</code> returns methods in an unspecified, non-deterministic order that can vary across:</p> <ul> <li>Different JVM implementations (OpenJDK vs Oracle JDK)</li> <li>Different versions of the same JVM</li> <li>Different runs of the same application</li> <li>Different class loading scenarios</li> <li>Code changes and recompilations</li> </ul> <p>This complete unpredictability makes handler execution order random without explicit priority control.</p>"},{"location":"annotations/#the-dangerous-reality","title":"The Dangerous Reality","text":""},{"location":"annotations/#the-problematic-code","title":"The Problematic Code","text":"<pre><code>@MessageHandler(commands = \"start\")\nvoid start(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Welcome message!\").exec();\n}\n\n@MessageHandler(commands = \"help\") \nvoid help(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Detailed help content\").exec();\n}\n\n@MessageHandler(regex = \"(start|help)\")\nvoid regex(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Generic help response\").exec();\n}\n</code></pre>"},{"location":"annotations/#what-could-happen","title":"What Could Happen","text":"<ol> <li>Development environment: <code>start</code> \u2192 <code>help</code> \u2192 <code>regex</code> (as declared)</li> <li>Production environment: <code>regex</code> \u2192 <code>start</code> \u2192 <code>help</code> (JVM reordering)</li> <li>After hot reload: <code>help</code> \u2192 <code>regex</code> \u2192 <code>start</code> (complete reshuffle)</li> <li>Different server: <code>regex</code> executes first and claims all <code>/start</code> and <code>/help</code> commands</li> </ol>"},{"location":"annotations/#the-catastrophic-result","title":"The catastrophic result:","text":"<p>The regex handler might execute first and handle both <code>/start</code> and <code>/help</code> commands, completely blocking the specific handlers from ever running!</p>"},{"location":"annotations/#why-priority-is-the-only-solution","title":"Why Priority is the Only Solution","text":""},{"location":"annotations/#the-working-solution","title":"The Working Solution","text":"<pre><code>@MessageHandler(commands = \"start\") // priority = 0 (default)\nvoid start(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Welcome message!\").exec();\n}\n\n@MessageHandler(commands = \"help\") // priority = 0 (default)\nvoid help(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Detailed help content\").exec();\n}\n\n@MessageHandler(regex = \"(start|help)\", priority = 1) // Explicit higher priority\nvoid regex(BotContext context, Message message) {\n    context.sendMessage(message.getChat().getId(), \"Generic help response\").exec();\n}\n</code></pre>"},{"location":"annotations/#how-priority-guarantees-order","title":"How Priority Guarantees Order","text":"<p>Execution is sorted by priority in ascending order:</p> <ol> <li>All priority = 0 handlers (<code>start</code> and <code>help</code>)</li> <li>All priority = 1 handlers (<code>regex</code>)</li> </ol> <p>Within same priority (like <code>start</code> and <code>help</code> both at priority=0), the order is still unpredictable, but this is acceptable because:</p> <ul> <li>They handle different commands (<code>/start</code> vs <code>/help</code>)</li> <li>They are mutually exclusive (no overlap)</li> <li>No risk of one blocking the other</li> </ul>"},{"location":"annotations/#key-characteristics","title":"Key Characteristics:","text":"<ol> <li>Lower numbers execute first (-100 before 0 before 1 before 100)</li> <li>Same priority order is unpredictable but safe for non-conflicting handlers</li> <li>Small differences work (priority=1 always executes after priority=0)</li> <li>Complete control over which handler \"wins\" for overlapping filters</li> </ol>"},{"location":"annotations/#the-non-negotiable-rule","title":"The Non-Negotiable Rule","text":"<p>Always use explicit priorities when handlers might match the same update with the same content.</p> <p>The only safe time to rely on default priority=0 is when:</p> <ol> <li>Handlers are completely mutually exclusive, AND</li> <li>There's no risk of one handler blocking another, AND</li> <li>You're willing to accept unpredictable order among them</li> </ol> <p>For any potential overlap or conflict, explicit priority control is mandatory.</p>"},{"location":"error_handling/","title":"Error Handling in Telebof","text":"<p>Proper error handling is crucial for building Telegram bots. Telebof provides a structured exception hierarchy to help you handle different types of API errors gracefully.</p>"},{"location":"error_handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All Telegram API exceptions inherit from the base <code>TelegramApiException</code> class. The exception hierarchy is organized as follows:</p> <pre><code>TelegramApiException (Base class)\n\u251c\u2500\u2500 Forbidden (403 errors)\n\u251c\u2500\u2500 BadRequest (400 errors)  \n\u2514\u2500\u2500 FloodError (429 rate limit errors)\n</code></pre> <p>These exceptions are defined in the <code>io.github.natanimn.telebof.exceptions</code> package.</p>"},{"location":"error_handling/#basic-error-handling-example","title":"Basic Error Handling Example","text":"<pre><code>import io.github.natanimn.telebof.exceptions.TelegramApiException;\n\ntry {     \n    context.sendMessage(message.chat.id, \"Hello, World\").exec();    \n} catch(TelegramApiException apiException){\n    System.out.println(\"Error: \" + apiException.getDescription());\n    System.out.println(\"Error code: \" + apiException.getErrorCode());\n}\n</code></pre> <p>Key Properties:</p> <ul> <li><code>description</code>: Human-readable error message from Telegram</li> <li><code>error_code</code>: Numeric HTTP status code (400, 403, 429, etc.)</li> </ul>"},{"location":"error_handling/#handling-specific-exception-types","title":"Handling Specific Exception Types","text":""},{"location":"error_handling/#1-forbidden-403-errors","title":"1. Forbidden (403 Errors)","text":"<p>Occurs when the bot doesn't have permission to perform an action.</p> <pre><code>import io.github.natanimn.telebof.exceptions.TelegramApiException;\nimport io.github.natanimn.telebof.exceptions.Forbidden;\n\ntry {\n    context.sendMessage(chat_id, \"Hello!\").exec();\n} catch (Forbidden e) {\n    // Bot was blocked by user or doesn't have chat permissions\n    System.out.println(\"Cannot send message: \" + e.getDescription());\n    // Example: \"Forbidden: bot was blocked by the user\"\n} catch (TelegramApiException e) {\n    System.out.println(\"Other API error: \" + e.getDescription());\n}\n</code></pre> <p>Common scenarios:</p> <ul> <li>Bot was blocked by the user</li> <li>Bot doesn't have permission to send messages in a chat</li> <li>Bot was removed from a group/channel</li> </ul>"},{"location":"error_handling/#2-badrequest400-errors","title":"2. BadRequest(400 Errors)","text":"<p>Occurs when the request contains invalid parameters.</p> <pre><code>import io.github.natanimn.telebof.exceptions.TelegramApiException;\nimport io.github.natanimn.telebof.exceptions.BadRequest;\n\ntry {\n    context.sendMessage(invalidChatId, \"Test message\").exec();\n} catch (BadRequest e) {\n    // Invalid parameters or malformed request\n    System.out.println(\"Bad request: \" + e.getDescription());\n    // Example: \"Bad Request: chat not found\"\n} catch (TelegramApiException e) {\n    System.out.println(\"Other API error: \" + e.getDescription());\n}\n</code></pre> <p>Common scenarios:</p> <ul> <li>Invalid chat ID</li> <li>Malformed message content</li> <li>Unsupported media types</li> <li>Exceeding maximum message length</li> </ul>"},{"location":"error_handling/#3-flooderror-429-errors","title":"3. FloodError (429 Errors)","text":"<p>Occurs when the bot exceeds Telegram's rate limits.</p> <pre><code>import io.github.natanimn.telebof.exceptions.TelegramApiException;\nimport io.github.natanimn.telebof.exceptions.FloodError;\n\ntry {\n    context.sendMessage(chatId, \"Message\").exec();\n} catch (FloodError e) {\n    // Rate limited - wait before retrying\n    System.out.println(\"Flood control: \" + e.getDescription());\n    System.out.println(\"Retry after: \" + e.getParameters.getRetryAfter() + \" seconds\");\n\n    // Implement retry logic with delay\n    Thread.sleep(e.retryAfter * 1000);\n    // Retry the operation here\n\n} catch (TelegramApiException e) {\n    System.out.println(\"Other API error: \" + e.getDescription());\n}\n</code></pre> <p>Key Property:</p> <ul> <li><code>parameters.retry_after</code>: Number of seconds to wait before retrying the request</li> </ul>"},{"location":"error_handling/#comprehensive-error-handling-example","title":"Comprehensive Error Handling Example","text":"<p>Here's a complete example showing structured error handling for different scenarios:</p> <pre><code>import io.github.natanimn.telebof.exceptions.TelegramApiException;\nimport io.github.natanimn.telebof.exceptions.Forbidden;\nimport io.github.natanimn.telebof.exceptions.BadRequest;\nimport io.github.natanimn.telebof.exceptions.FloodError;\n\npublic class ErrorHandlingExample {\n\n    public void sendSafeMessage(BotContext context, Long chatId, String text) {\n        try {\n            context.sendMessage(chatId, text).exec();\n\n        } catch (Forbidden e) {\n            System.out.println(\"Permission denied: \" + e.getDescription());\n            // Handle blocked bot scenario - maybe remove user from database\n\n        } catch (FloodError e) {\n            System.out.println(\"Rate limited. Retrying in \" + e.getParameters().getRetryAfter() + \" seconds\");\n            // Implement retry logic with exponential backoff\n\n        } catch (BadRequest e) {\n            System.out.println(\"Invalid request: \" + e.getDescription());\n\n\n        } catch (TelegramApiException e) {\n            System.out.println(\"Unexpected API error (\" + e.getErrorCode() + \"): \" + e.getDescription());\n            // Handle other unexpected errors\n\n        } catch (Exception e) {\n            System.out.println(\"Non-API error: \" + e.getMessage());\n            // Handle other exceptions \n        }\n    }\n}\n</code></pre>"},{"location":"error_handling/#common-error-scenarios-and-solutions","title":"Common Error Scenarios and Solutions","text":"Error Type Common Causes Recommended Action Forbidden Bot blocked, no permissions Remove user from DB, log incident BadRequest Invalid parameters, long messages Validate input, truncate content FloodError Rate limiting Implement retry with exponential backoff"},{"location":"examples/","title":"Example Bots Gallery","text":"<p>This section provides a comprehensive overview of working example bots built with Telebof. Each example demonstrates specific features and capabilities of the library, serving as building blocks for your own applications.</p> <p>All examples are production-ready and can be run immediately after setting up your bot token credentials.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"Example Description Key Features Demonstrated KeyboardBot Interactive bot with custom reply keyboard Reply keyboards, button handling, user input processing InlineKeyboardBot Bot with interactive inline buttons Inline keyboards, callback queries, message editing InlineBot Inline mode implementation Inline queries, instant results, cross-chat functionality PaymentBot Telegram Stars payment integration Payment processing, invoices, pre-checkout queries StateBot Multi-step conversation handling State management, conversational flows, data persistence WelcomeBot Group welcome and moderation bot New member handling, permissions checking, auto-moderation MediaDownloader File download and storage system Media handling, file operations, custom filters Spring Boot Webhook Bot Webhook bot using Spring boot framework Handling rest endpoints"},{"location":"filters/","title":"Filtering Updates","text":"<p>In the previous topic, we learned how to create handlers and how they work. This section will explain how filters work and how to use them.</p> <p>As previously discussed, all handlers take two parameters: a filter class and a callback class.</p> <p>The filter class is used for filtering the content of updates and separating updates based on the content they contain.</p>"},{"location":"filters/#predefined-filters","title":"Predefined Filters","text":""},{"location":"filters/#message-content-filters","title":"Message Content Filters","text":""},{"location":"filters/#filtertext","title":"filter.text()","text":"<p>Filters text messages</p>"},{"location":"filters/#filterphoto","title":"filter.photo()","text":"<p>Filters photo messages</p>"},{"location":"filters/#filtervideo","title":"filter.video()","text":"<p>Filters video messages</p>"},{"location":"filters/#filtervoice","title":"filter.voice()","text":"<p>Filters voice messages</p>"},{"location":"filters/#filteraudio","title":"filter.audio()","text":"<p>Filters audio messages</p>"},{"location":"filters/#filteranimation","title":"filter.animation()","text":"<p>Filters animation messages</p>"},{"location":"filters/#filterdocument","title":"filter.document()","text":"<p>Filters document messages</p>"},{"location":"filters/#filtervideonote","title":"filter.videoNote()","text":"<p>Filters video note messages</p>"},{"location":"filters/#filtercontact","title":"filter.contact()","text":"<p>Filters contact messages</p>"},{"location":"filters/#filterlocation","title":"filter.location()","text":"<p>Filters location messages</p>"},{"location":"filters/#filtergame","title":"filter.game()","text":"<p>Filters game messages</p>"},{"location":"filters/#filtervenue","title":"filter.venue()","text":"<p>Filters venue messages</p>"},{"location":"filters/#filtersticker","title":"filter.sticker()","text":"<p>Filters sticker messages</p>"},{"location":"filters/#filterdice","title":"filter.dice()","text":"<p>Filters dice messages</p>"},{"location":"filters/#filterinvoice","title":"filter.invoice()","text":"<p>Filters payment invoice messages</p>"},{"location":"filters/#filtermedia","title":"filter.media()","text":"<p>Filters media messages (photo, video, audio, sticker, video_note, voice, animation, document)</p>"},{"location":"filters/#filterpassportdata","title":"filter.passportData()","text":"<p>Filters Telegram passport data messages</p>"},{"location":"filters/#filterusersshared","title":"filter.usersShared()","text":"<p>Filters when users are shared with the bot</p>"},{"location":"filters/#filterchatshared","title":"filter.chatShared()","text":"<p>Filters when a chat is shared with the bot</p>"},{"location":"filters/#filterchecklist","title":"filter.checklist()","text":"<p>Filters checklist messages</p>"},{"location":"filters/#chat-event-filters","title":"Chat Event Filters","text":""},{"location":"filters/#filternewchatmember","title":"filter.newChatMember()","text":"<p>Filters when new members join or are added to the group</p>"},{"location":"filters/#filterleftchatmember","title":"filter.leftChatMember()","text":"<p>Filters when a member leaves the group</p>"},{"location":"filters/#filternewchatphoto","title":"filter.newChatPhoto()","text":"<p>Filters when a chat photo is changed</p>"},{"location":"filters/#filternewchattitle","title":"filter.newChatTitle()","text":"<p>Filters when a chat title is changed</p>"},{"location":"filters/#filtergroupcreated","title":"filter.groupCreated()","text":"<p>Filters when a group chat is created</p>"},{"location":"filters/#filtersupergroupcreated","title":"filter.supergroupCreated()","text":"<p>Filters when a supergroup chat is created</p>"},{"location":"filters/#filterchannelcreated","title":"filter.channelCreated()","text":"<p>Filters when a channel is created</p>"},{"location":"filters/#filtermessageautodeletetimerchanged","title":"filter.messageAutoDeleteTimerChanged()","text":"<p>Filters when auto-delete timer settings change in the chat</p>"},{"location":"filters/#filtermigrated","title":"filter.migrated()","text":"<p>Filters when a group/supergroup is migrated to/from a supergroup/group</p>"},{"location":"filters/#filterchatbackgroundset","title":"filter.chatBackgroundSet()","text":"<p>Filters when a chat background is set</p>"},{"location":"filters/#filterpinnedmessage","title":"filter.pinnedMessage()","text":"<p>Filters when a message is pinned</p>"},{"location":"filters/#filtersuccessfulpayment","title":"filter.successfulPayment()","text":"<p>Filters successful payment messages</p>"},{"location":"filters/#filterrefundedpayment","title":"filter.refundedPayment()","text":"<p>Filters refunded payment messages</p>"},{"location":"filters/#filterproximityalerttriggered","title":"filter.proximityAlertTriggered()","text":"<p>Filters when a user triggers another user's proximity alert</p>"},{"location":"filters/#filterboostadded","title":"filter.boostAdded()","text":"<p>Filters when a user boosts the chat</p>"},{"location":"filters/#filtergiveaway","title":"filter.giveaway()","text":"<p>Filters scheduled giveaway messages</p>"},{"location":"filters/#filtergiveawaycreated","title":"filter.giveawayCreated()","text":"<p>Filters when a scheduled giveaway is created</p>"},{"location":"filters/#filtergiveawaycompleted","title":"filter.giveawayCompleted()","text":"<p>Filters when a giveaway without public winners is completed</p>"},{"location":"filters/#forum-topic-filters","title":"Forum Topic Filters","text":""},{"location":"filters/#filterforumtopiccreated","title":"filter.forumTopicCreated()","text":"<p>Filters when a forum topic is created</p>"},{"location":"filters/#filterforumtopicclosed","title":"filter.forumTopicClosed()","text":"<p>Filters when a forum topic is closed</p>"},{"location":"filters/#filterforumtopicedited","title":"filter.forumTopicEdited()","text":"<p>Filters when a forum topic is edited</p>"},{"location":"filters/#filterforumtopicreopened","title":"filter.forumTopicReopened()","text":"<p>Filters when a forum topic is reopened</p>"},{"location":"filters/#filterchecklisttasksadded","title":"filter.checklistTasksAdded","text":"<p>Filters when checklist task is added</p>"},{"location":"filters/#filterchecklisttasksdone","title":"filter.checklistTasksDone","text":"<p>Filters when checklist task is added</p>"},{"location":"filters/#filterdirectmessagepricechanged","title":"filter.directMessagePriceChanged","text":"<p>Filters when direct message price is changed</p>"},{"location":"filters/#video-chat-filters","title":"Video Chat Filters","text":""},{"location":"filters/#filterwebappdata","title":"filter.webAppData()","text":"<p>Filters data sent by a Web App</p>"},{"location":"filters/#filtervideochatstarted","title":"filter.videoChatStarted()","text":"<p>Filters when a video chat starts in the chat</p>"},{"location":"filters/#filtervideochatended","title":"filter.videoChatEnded()","text":"<p>Filters when a video chat ends in the chat</p>"},{"location":"filters/#filtervideochatparticipantsinvited","title":"filter.videoChatParticipantsInvited()","text":"<p>Filters when new participants are invited to a video chat</p>"},{"location":"filters/#filtervideochatscheduled","title":"filter.videoChatScheduled()","text":"<p>Filters when a video chat is scheduled</p>"},{"location":"filters/#message-context-filters","title":"Message Context Filters","text":""},{"location":"filters/#filterforwarded","title":"filter.forwarded()","text":"<p>Filters forwarded messages</p>"},{"location":"filters/#filterreplied","title":"filter.replied()","text":"<p>Filters messages that are replies to another message</p>"},{"location":"filters/#filterrepliedtostory","title":"filter.repliedToStory()","text":"<p>Filters messages that are replies to a chat story</p>"},{"location":"filters/#filterentities","title":"filter.entities()","text":"<p>Filters messages containing entities (bold, italic, underline, mention, url, hashtag)</p>"},{"location":"filters/#filterquote","title":"filter.quote()","text":"<p>Filters messages containing quotes</p>"},{"location":"filters/#user-and-chat-type-filters","title":"User and Chat Type Filters","text":""},{"location":"filters/#filterbot","title":"filter.bot()","text":"<p>Filters when the user is a bot</p>"},{"location":"filters/#filteremptyquery","title":"filter.emptyQuery()","text":"<p>Filters empty queries Used with <code>bot.onInline</code> handler</p>"},{"location":"filters/#filterprivate","title":"filter.Private()","text":"<p>Filters private chats</p>"},{"location":"filters/#filtergroup","title":"filter.group()","text":"<p>Filters group chats</p>"},{"location":"filters/#filtersupergroup","title":"filter.supergroup()","text":"<p>Filters supergroup chats</p>"},{"location":"filters/#filterchannel","title":"filter.channel()","text":"<p>Filters channel chats</p>"},{"location":"filters/#advanced-filtering-methods","title":"Advanced Filtering Methods","text":""},{"location":"filters/#filtercommandsstring-commands","title":"filter.commands(String... commands)","text":"<p>Filters specific commands</p> <ul> <li>Used with handles that recieves <code>Message</code> update</li> </ul>"},{"location":"filters/#filtercallbackdatastring-datas","title":"filter.callbackData(String... datas)","text":"<p>Filters specific callback data from buttons</p> <ul> <li>Used with <code>bot.onCallback</code> handler</li> </ul>"},{"location":"filters/#filterinlinequerystring-queries","title":"filter.inlineQuery(String... queries)","text":"<p>Filters specific inline queries</p> <ul> <li>Used with <code>bot.onInline</code> handler</li> </ul>"},{"location":"filters/#filtercustomfiltercustomfilter-cf","title":"filter.customFilter(CustomFilter cf)","text":"<p>Applies a custom filter</p>"},{"location":"filters/#filterstatestring-state","title":"filter.state(String state)","text":"<p>Filters by current state (use <code>*</code> for any state)</p>"},{"location":"filters/#filtertextsstring-texts","title":"filter.texts(String... texts)","text":"<p>Filters specific text messages</p>"},{"location":"filters/#filterchatidslong-ids","title":"filter.chatIds(Long... ids)","text":"<p>Filters by chat ID</p>"},{"location":"filters/#filterfromidslong-ids","title":"filter.fromIds(Long... ids)","text":"<p>Filters by user ID</p>"},{"location":"filters/#filterchatusernamesstring-usernames","title":"filter.chatUsernames(String... usernames)","text":"<p>Filters by chat username</p>"},{"location":"filters/#filterusernamesstring-usernames","title":"filter.usernames(String... usernames)","text":"<p>Filters by user username</p>"},{"location":"filters/#filterregexstring-pattern","title":"filter.regex(String pattern)","text":"<p>Filter updates that match a given regular expression pattern. Used with handlers that receive one of the following updates:</p> <ul> <li>Message - The filter will match text</li> <li>CallbackData - The filter will match data.</li> <li>InlineQuery - The filter will match query.</li> <li>PreCheckoutQuery: The filter will match payload</li> </ul>"},{"location":"filters/#filterreactionstring-reactions","title":"filter.reaction(String... reactions)","text":"<p>Filters emoji reactions</p> <ul> <li>Used with <code>bot.OnReaction</code> handler</li> </ul>"},{"location":"filters/#usage-examples","title":"Usage Examples","text":""},{"location":"filters/#basic-message-handling","title":"Basic Message Handling","text":"<pre><code>// Handles incoming texts\nbot.onMessage(filter -&gt; filter.text(), (context, message) -&gt; {});\n\n// Handles incoming photos\nbot.onMessage(filter -&gt; filter.photo(), (context, message) -&gt; {});\n\n// Handles incoming videos\nbot.onMessage(filter -&gt; filter.video(), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#id-and-username-filtering","title":"ID and Username Filtering","text":"<pre><code>// Handles messages in chat with chat_id of 123456789\nbot.onMessage(filter -&gt; filter.chatIds(123456789L), (context, message) -&gt; {});\n\n// Handles messages from user with ID 123456789\nbot.onMessage(filter -&gt; filter.fromIds(123456789L), (context, message) -&gt; {});\n\n// Handles messages in chat with username @this_chat\nbot.onMessage(filter -&gt; filter.chatUsernames(\"this_chat\"), (context, message) -&gt; {});\n\n// Handles messages from user with username @this_user\nbot.onMessage(filter -&gt; filter.usernames(\"this_user\"), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#filtering-message-text","title":"Filtering Message Text","text":""},{"location":"filters/#command-filtering","title":"Command Filtering","text":"<pre><code>// Handles /start command\nbot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {});\n\n// Handles /help command\nbot.onMessage(filter -&gt; filter.commands(\"help\"), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#text-filtering","title":"Text Filtering","text":"<pre><code>// Handles \"hi\" text\nbot.onMessage(filter -&gt; filter.texts(\"hi\"), (context, message) -&gt; {});\n\n// Handles \"hello\" text\nbot.onMessage(filter -&gt; filter.texts(\"hello\"), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#regular-expression-filtering","title":"Regular Expression Filtering","text":"<pre><code>// Handles any text starting with \"hi\"\nbot.onMessage(filter -&gt; filter.regex(\"^hi\"), (context, message) -&gt; {});\n\n// Handles any text ending with \"bye\"\nbot.onMessage(filter -&gt; filter.regex(\"bye$\"), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#combining-filters","title":"Combining Filters","text":"<p>You can combine filters using logical operators (&amp;&amp;, ||, !) to create more complex filtering conditions.</p> <pre><code>// Handles incoming text in private chat\nbot.onMessage(filter -&gt; filter.text() &amp;&amp; filter.Private(), (context, message) -&gt; {});\n\n// Handles incoming text or photo\nbot.onMessage(filter -&gt; filter.text() || filter.photo(), (context, message) -&gt; {});\n\n// Handles incoming text in supergroup chat\nbot.onMessage(filter -&gt; filter.text() &amp;&amp; filter.supergroup(), (context, message) -&gt; {});\n\n// Handles incoming audio or video in private chat\nbot.onMessage(filter -&gt; filter.Private() &amp;&amp; (filter.audio() || filter.video()), (context, message) -&gt; {});\n</code></pre>"},{"location":"filters/#writing-custom-filters","title":"Writing Custom Filters","text":"<p>You can create custom filters using <code>filter.customFilter()</code> with a <code>CustomFilter</code> implementation.</p>"},{"location":"filters/#example-custom-text-filter","title":"Example: Custom Text Filter","text":"<pre><code>import io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.filters.CustomFilter;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.updates.Update;\n\n// Filter to check if incoming message text starts with a given prefix\nclass PrefixFilter implements CustomFilter {\n    private String prefix;\n\n    public StartsWithFilter(String prefix){\n        this.prefix = prefix;\n    }\n\n    @Override\n    public boolean check(Update update) {\n        return update.message.text.startsWith(this.prefix);\n    }\n}\n\npublic class FilterBot {\n    public static void main(String[] args) {\n        // ...\n\n        // Handles any message/command starts with \"!\"(i.e !start, !hello world)\n        bot.onMessage(\n            filter -&gt; filter.text() &amp;&amp; filter.customFilter(new PrefixFilter(\"!\")),\n            (context, message) -&gt; {\n                context.sendMessage(message.getChat().getId(), \"Message starts with !\").exec();\n            }\n        );\n\n\n        // Handles any message/command starts with dot(.)(i.e .start, .hello world)\n        bot.onMessage(\n            filter -&gt; filter.text() &amp;&amp; filter.customFilter(new PrefixFilter(\".\")),\n            (context, message) -&gt; {\n                context.sendMessage(message.getChat().getId(), \"Message starts with dot(.)\").exec();\n            }\n        );\n    }\n}\n</code></pre>"},{"location":"filters/#example-complex-custom-filter","title":"Example: Complex Custom Filter","text":"<pre><code>// Filter for messages containing specific keywords from admin users\nclass AdminKeywordFilter implements CustomFilter {\n    private List&lt;Long&gt; adminIds = Arrays.asList(12345L, 67890L);\n    private List&lt;String&gt; keywords = Arrays.asList(\"urgent\", \"important\", \"emergency\");\n\n    @Override\n    public boolean check(Update update) {\n        if (update.message == null || update.getMessage().getText() == null) {\n            return false;\n        }\n\n        boolean isAdmin = adminIds.contains(update.getMessage().getFrom().getId());\n        boolean containsKeyword = keywords.stream().anyMatch(update.getMessage().getText::toLowerCase::contains);\n\n        return isAdmin &amp;&amp; containsKeyword;\n    }\n}\n\n// Usage\nbot.onMessage(filter -&gt; filter.customFilter(new AdminKeywordFilter()), (context, message) -&gt; {\n    context.sendMessage(message.getChat().getId(), \"Admin urgent message detected!\").exec();\n});\n</code></pre>"},{"location":"filters/#advanced-filters","title":"Advanced Filters","text":""},{"location":"filters/#callback-data-filtering","title":"Callback Data Filtering","text":"<ul> <li>Used with <code>bot.onCallback</code> <pre><code>// Handles inline button with callback data \"a\"\nbot.onCallback(filter -&gt; filter.callbackData(\"a\"), (context, callback) -&gt; {\n    context.answerCallbackQuery(callback.getId(), \"You pressed A button!\").exec();\n\n});\n</code></pre></li> </ul>"},{"location":"filters/#inline-query-filtering","title":"Inline Query Filtering","text":"<ul> <li>Used with <code>bot.onInline</code></li> </ul> <pre><code>// Handles inline query with the word \"hello\"\nbot.onInline(filter -&gt; filter.inlineQuery(\"hello\"), (context, query) -&gt; {});\n</code></pre>"},{"location":"filters/#state-filter-example","title":"State Filter Example","text":"<p>State filters are useful for creating conversational flows with the bot.</p> <pre><code>// Set state when /start command is received\nbot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n    context.sendMessage(message.getChat().getId(), \"What is your name?\").exec();\n    bot.setState(message.getFrom().getId(), \"name\"); // Set state to 'name'\n});\n\n// Handle response when in 'name' state\nbot.onMessage(filter -&gt; filter.state(\"name\") &amp;&amp; filter.text(), (context, message) -&gt; {     \n    context.sendMessage(message.getChat().getId(), String.format(\"Your name is %s\", message.getText())).exec();\n    context.clearState(message.getFrom().getId()); // Clear the state\n});\n</code></pre>"},{"location":"handling-updates/","title":"Handling Updates","text":""},{"location":"handling-updates/#what-is-an-update","title":"What is an Update?","text":"<p>An update is an event sent by Telegram to your bot \u2014 for example, a new message, a button press, a poll answer, or a payment event. In Telebof, you handle updates by using handler method or annotation (Recommended).</p> <p>In this section, we will learn how we can handle updates by using handler methods</p> <p>Each handler method:</p> <ul> <li>Accepts a filter to determine which updates it should process.</li> <li>Accepts a callback that is executed when the filter matches.</li> </ul> <p>Filter The filter is a lambda of type <code>io.github.natanimn.telebof.filter.FilterExecutor</code>, which takes a <code>io.github.natanimn.telebof.filter.Filter</code> object and returns a <code>Boolean</code>. If the filter condition matches the incoming update, the callback is triggered.</p> <p>Callback The callback is a function that takes two parameters:</p> <ol> <li><code>io.github.natanimn.telebof.BotContext</code> \u2013 allows sending messages, editing content, etc.</li> <li>The specific update type being handled.</li> </ol>"},{"location":"handling-updates/#example-basic-echo-bot","title":"Example: Basic Echo Bot","text":"<p>Let\u2019s revisit our first echo bot:</p> <pre><code>import io.github.natanimn.telebof.BotClient;\n\npublic class MyFirstBot {\n  static final String TOKEN = \"YOUR_BOT_TOKEN_HERE\";\n\n  public static void main(String[] args) {\n    final BotClient bot = new BotClient(TOKEN);\n\n    // Responding to /start command\n    bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n        context.sendMessage(message.getChat().getId(), \"Welcome!\").exec();\n    });\n\n    // Echoing any incoming text\n    bot.onMessage(filter -&gt; filter.text(), (context, message) -&gt; {\n        context.sendMessage(message.getChat().getId(), message.getText()).exec();\n    });\n\n    bot.startPolling(); // Start the bot\n  }\n}\n</code></pre> <p>In this example:</p> <ul> <li>First handler: Responds to /start with \u201cWelcome!\u201d.</li> <li>Second handler: Echoes any text sent to the bot.</li> <li><code>sendMessage</code> sends a message.</li> <li> <p><code>exec()</code> executes the request to Telegram.</p> </li> <li> <p>Optional parameters (e.g., parse_mode, reply_markup) can be set before calling exec().</p> </li> </ul> <p>Example with Markdown parse mode: <pre><code>import enums.\nio.github.natanimn.telebof.ParseMode;\n\ncontext.sendMessage(message.getChat().getId(), \"*Hello, World*\")\n       .parseMode(ParseMode.MARKDOWN)\n       .exec();\n</code></pre> - <code>startPolling()</code> Starts the bot using long polling, continuously fetching updates from Telegram.</p> <p>Important: Handlers are executed in the order they are registered. If multiple handlers match the same update, earlier ones run first.</p>"},{"location":"handling-updates/#types-of-handlers","title":"Types of Handlers","text":"<p>Telegram bots can receive a variety of updates, each representing a different type of event. Telebof provides 22 handler methods to process these updates easily.</p>"},{"location":"handling-updates/#all-update-types-in-telebof","title":"All Update Types in Telebof","text":"Update Type Handler Method Description Message <code>bot.onMessage</code> Handles incoming messages from users or groups. Callback Query <code>bot.onCallback</code> Handles button presses from inline keyboards. Inline Query <code>bot.onInline</code> Handles inline queries typed in other chats. Poll <code>bot.onPoll</code> Handles new polls. Poll Answer <code>bot.onPollAnswer</code> Handles answers to polls. Shipping Query <code>bot.onShipping</code> Handles shipping related queries for payments. Channel Post <code>bot.onChannelPost</code> Handles new channel posts. Pre-Checkout Query <code>bot.onPreCheckout</code> Handles payment pre-checkout events. Edited Message <code>bot.onEditedMessage</code> Handles edits to existing messages. Edited Channel Post <code>bot.onEditedChannelPost</code> Handles edits to channel posts. My Chat Member <code>bot.onMyChatMember</code> Handles changes to the bot's role in a chat. Chat Member <code>bot.onChatMember</code> Handles changes to a user's role in a chat. Chosen Inline Result <code>bot.onChosenInlineResult</code> Handles the result chosen from an inline query. Message Reaction <code>bot.onReaction</code> Handles when someone reacts to a message. Message Reaction Count <code>bot.onReactionCount</code> Handles updates to reaction counts. Chat Boost <code>bot.onChatBoost</code> Handles when a chat is boosted. Removed Chat Boost <code>bot.onRemovedChatBoost</code> Handles when a boost is removed from a chat. Business Message <code>bot.onBusinessMessage</code> Handles new business messages. Business Connection <code>bot.onBusinessConnection</code> Handles new or updated business connections. Edited Business Message <code>bot.onEditedBusinessMessage</code> Handles edits to business messages. Deleted Business Message <code>bot.onDeletedBusinessMessage</code> Handles deletions of business messages."},{"location":"handling-updates/#usages","title":"Usages","text":"<p>1. Handling Different Message Types</p> <pre><code>// Handle text messages\nbot.onMessage(filter -&gt; filter.text(), (context, message) -&gt; {\n    context.sendMessage(message.getChat().getId(), \"You said: \" + message.getText()).exec();\n});\n\n// Handle photo messages\nbot.onMessage(filter -&gt; filter.photo(), (context, message) -&gt; {\n    context.sendMessage(message.getChat().getId(), \"Nice photo!\").exec();\n});\n\n// Handle document messages\nbot.onMessage(filter -&gt; filter.document(), (context, message) -&gt; {\n    context.sendMessage(message.getChat().getId(), \"File received\").exec();\n});\n</code></pre> <p>2. Handling Callback Queries from Inline Keyboards</p> <pre><code>bot.onCallback(filter -&gt; filter.calbackData(\"button_1\"), (context, callback) -&gt; {\n    context.answerCallbackQuery(callback.getId(), \"Button 1 pressed!\").exec();\n\n    context.editMessageText(\n            \"You pressed Button 1\", \n            callback.getMessage().getChat().getId(), \n            callback.getMessage().getMessageId()).exec();\n});\n</code></pre> <p>3. Handling Inline Queries</p> <pre><code>bot.onInline(filter -&gt; true, (context, inline) -&gt; {\n    var result = new InlineQueryResultArticle(\n            \"1\", \n            \"Title\", \n            new InputTextMessageContent(\"Hello from inline!\")\n    );\n    context.answerInlineQuery(inline.getId(), new InlineQueryResult[]{result}).exec();\n});\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Telebof is available via Maven and Gradle, making it easy to integrate into any Java project. Make sure you have Java 20 or above installed.  </p>"},{"location":"installation/#maven","title":"Maven","text":"<p>Add the following dependency to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.natanimn&lt;/groupId&gt;\n    &lt;artifactId&gt;telebof&lt;/artifactId&gt;\n    &lt;version&gt;1.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"installation/#gradle","title":"Gradle","text":"<p>Add this line to your <code>build.gradle</code> dependencies:</p> <pre><code>implementation 'io.github.natanimn:telebof:1.4.0'\n</code></pre>"},{"location":"states/","title":"States in Telebof","text":"<p>The States system in Telebof allows bots to manage multi step conversations by keeping track of a user's current step and storing temporary data. This feature is essential for building forms, surveys, and context aware interactions.</p>"},{"location":"states/#overview","title":"Overview","text":"<p>A state represents the current step a user is at in a conversation. Each state can store associated data, enabling the bot to retrieve and use it in subsequent steps. States can exist in:</p> <ul> <li>Private chats (per user)</li> <li>Group or supergroup chats (per user in a chat)</li> </ul>"},{"location":"states/#botcontext-managing-states","title":"BotContext: Managing States","text":"<p><code>BotContext</code> provides methods to set, clear, and retrieve states and their data.</p>"},{"location":"states/#set-state","title":"Set State","text":"<ul> <li>Private chat:</li> </ul> <pre><code>context.setState(user_id, \"state_name\");\n</code></pre> <ul> <li>Group/Supergroup chat:</li> </ul> <pre><code>context.setState(chat_id, user_id, \"state_name\");\n</code></pre>"},{"location":"states/#clear-state","title":"Clear State","text":"<ul> <li>Private chat:</li> </ul> <pre><code>context.clearState(user_id);\n</code></pre> <ul> <li>Group/Supergroup chat:</li> </ul> <pre><code>context.clearState(chat_id, user_id);\n</code></pre>"},{"location":"states/#retrieve-state-data","title":"Retrieve State Data","text":"<ul> <li>Private chat:</li> </ul> <pre><code>Map&lt;String, Object&gt; data = \ncontext.getStateData(user_id);\n</code></pre> <ul> <li>Group/Supergroup chat:</li> </ul> <pre><code>Map&lt;String, Object&gt; data = \ncontext.getStateData(chat_id, user_id);\n</code></pre> <p>Use the returned <code>Map&lt;String, Object&gt;</code> to store and access temporary data associated with the user\u2019s current state.</p>"},{"location":"states/#filterstate","title":"filter.state","text":"<ul> <li>Returns <code>true</code> if the user is currently in the given state.</li> <li>Special case: <code>\"*\"</code> matches any active state.</li> <li>Works for both messages and callback queries.</li> <li>Checks states in private chats and group/supergroup chats.</li> </ul> <p>Usage Example:</p> <pre><code>bot.onMessage(filter -&gt; filter.state(\"name\"), handler);\nbot.onMessage(filter -&gt; filter.commands(\"cancel\") &amp;&amp; filter.state(\"*\"), cancelHandler);\n</code></pre>"},{"location":"states/#tips-for-using-states","title":"Tips for Using States","text":"<ol> <li>Use <code>\"*\"</code> in <code>filter.state(\"*\")</code> to match any active state.</li> <li>Always clear states after the flow is complete or on cancellation.</li> <li>Store intermediate data in <code>getStateData()</code> for multi step flows.</li> <li>Works seamlessly in both private and group chats.</li> </ol> <p>Full example code can be found on StateBot</p>"},{"location":"examples/inline_bot/","title":"Inline Mode Bot","text":"<p>In this example section, we will create a bot that supports Telegram's inline mode, allowing users to interact with the bot directly from any chat by typing <code>@botusername query</code>. This enables powerful features like instant content sharing, quick searches, and seamless bot interactions without leaving the current conversation.</p> <p>We will use two different types of handlers:</p> <ul> <li><code>onMessage</code> or <code>@MessageHandler</code> for handling commands in private chats</li> <li><code>onInline</code> or <code>@InlineHandler</code> for handling inline queries from any chat</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.inline.InlineQueryResult;\nimport io.github.natanimn.telebof.types.inline.InlineQueryResultArticle;\nimport io.github.natanimn.telebof.types.input.InputTextMessageContent;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.updates.Message;\nimport io.github.natanimn.telebof.updates.InlineQuery;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.inline.InlineQueryResult;\nimport io.github.natanimn.telebof.types.inline.InlineQueryResultArticle;\nimport io.github.natanimn.telebof.types.input.InputTextMessageContent;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\nimport io.github.natanimn.telebof.annotations.MessageHandler;\nimport io.github.natanimn.telebof.annotations.InlineHandler;\n</code></pre> <p>Create <code>InlineBot</code> class and initialize <code>BotClient</code> with a <code>token</code></p> MethodAnnotation <pre><code>public class InlineBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\"); // Get bot token from environment variable\n        final var bot = new BotClient(TOKEN); // Initialize bot client\n\n        // Add handlers here\n\n        bot.startPolling(); // Start the bot\n    }\n}\n</code></pre> <pre><code>public class InlineBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\"); // Get bot token from environment variable\n        final var bot = new BotClient(TOKEN); // Initialize bot client\n\n        bot.addHandler(new InlineBot());\n\n        bot.startPolling(); // Start the bot\n    }\n}\n</code></pre> <p>Our bot will be handling the following events:</p> <ul> <li><code>/start</code> command in private chat</li> <li>Empty inline queries (when user just types <code>@botusername</code>)</li> <li>Inline queries with text input</li> </ul> <p>Create <code>/start</code> handler with inline button</p> <p>When the user types <code>/start</code> in a private chat, the bot responds with a message containing a button that triggers inline mode.</p> MethodAnnotation <pre><code>bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n    // Create an inline keyboard with a button that opens inline mode\n    var keyboard = new InlineKeyboardMarkup(new InlineKeyboardButton[]{\n            new InlineKeyboardButton(\"Inline\").setSwitchInlineQueryCurrentChat(\"\")\n    });\n\n    // Send welcome message with the inline button\n    context.sendMessage(message.getChat().getId(), \"Hi! I am an inline bot. Press the button below to try inline mode\")\n            .replyMarkup(keyboard) // Attach the inline keyboard\n            .exec();\n});\n</code></pre> <pre><code>@MessageHandler(commands = \"start\")\nvoid start(BotContext context, Message message){\n    // Create an inline keyboard with a button that opens inline mode\n    var keyboard = new InlineKeyboardMarkup(new InlineKeyboardButton[]{\n        new InlineKeyboardButton(\"Inline\").setSwitchInlineQueryCurrentChat(\"\")\n    });\n\n    // Send welcome message with the inline button\n    context.sendMessage(message.getChat().getId(), \"Hi! I am an inline bot. Press the button below to try inline mode\")\n            .replyMarkup(keyboard) // Attach the inline keyboard\n            .exec();\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>InlineKeyboardMarkup</code> creates an inline keyboard that appears below the message</li> <li><code>InlineKeyboardButton(\"Inline\")</code> creates a button with the specified text</li> <li><code>.setSwitchInlineQueryCurrentChat(\"\")</code> makes the button open inline mode in the current chat when pressed</li> <li>The empty string <code>\"\"</code> means no pre-filled query text</li> </ul> <p>Result: </p> <p>Handle empty inline queries</p> <p>This handler is triggered when a user types just the bot's username (<code>@botusername</code>) without any additional text.</p> MethodAnnotation <pre><code>bot.onInline(filter -&gt; filter.emptyQuery(), (context, query) -&gt; {\n    // Create a result for empty queries\n    var result = new InlineQueryResultArticle(\n            \"1\", // Unique identifier for this result\n            \"Write something\", // Title shown to the user\n            new InputTextMessageContent(\"Write something\") // Content that will be sent\n    );\n\n    // Send the result to the user\n    context.answerInlineQuery(query.getId(), new InlineQueryResult[]{result}).exec();\n});\n</code></pre> <p>Explanation:</p> <ul> <li><code>filter.emptyQuery()</code> matches when the user doesn't provide any search text</li> <li><code>InlineQueryResultArticle</code> creates a clickable result item</li> <li><code>\"1\"</code> is a unique ID for this result (Can be any string)</li> <li><code>\"Write something\"</code> is the title shown in the results list</li> <li><code>InputTextMessageContent(\"Write something\")</code> is the message that will be sent if the user selects this result</li> <li><code>answerInlineQuery()</code> sends the results back to Telegram for display</li> </ul> <p><pre><code>@InlineHandler\nvoid inline(BotContext context, InlineQuery query){\n    if (query.getQuery().equals(\"\")){\n        // Create a result for empty queries\n        var result = new InlineQueryResultArticle(\n            \"1\", // Unique identifier for this result\n            \"Write something\", // Title shown to the user\n            new InputTextMessageContent(\"Write something\") // Content that will be sent\n        );\n\n        // Send the result to the user\n        context.answerInlineQuery(query.getId(), new InlineQueryResult[]{result}).exec();\n    }\n}\n</code></pre> Explanation:</p> <ul> <li><code>if (query.getQuery().eqals(\"\"))</code> matches when the user doesn't provide any search text</li> <li><code>InlineQueryResultArticle</code> creates a clickable result item</li> <li><code>\"1\"</code> is a unique ID for this result (Can be any string)</li> <li><code>\"Write something\"</code> is the title shown in the results list</li> <li><code>InputTextMessageContent(\"Write something\")</code> is the message that will be sent if the user selects this result</li> <li><code>answerInlineQuery()</code> sends the results back to Telegram for display</li> </ul> <p></p> <p>Handle inline queries with text input</p> <p>This handler processes inline queries where the user provides text after the bot's username (e.g., <code>@botusername hello world</code>).</p> MethodAnnotation <pre><code>bot.onInline(_ -&gt; true, (context, query) -&gt; {\n    // Create a result that echoes the user's input\n    var result = new InlineQueryResultArticle.builder(\n            \"2\", // Unique identifier\n            query.getQuery(), // Title shows the user's query\n            new InputTextMessageContent(\"&lt;b&gt;You said:&lt;/b&gt; \" + query.getQuery())\n                    .setParseMode(ParseMode.HTML)\n    )\n        .setDscription(\"Click here\"); // Optional description below the title\n\n    // Send the result\n    context.answerInlineQuery(query.getId(), new InlineQueryResult[]{result}).exec();\n});\n</code></pre> <p>Explanation:</p> <ul> <li><code>_ -&gt; true</code> acts as a catch all for all inline queries (after the empty query handler)</li> <li><code>query.getQuery()</code> contains the text the user typed after the bot's username</li> <li><code>InputTextMessageContent()</code> creates formatted message content with HTML parsing</li> <li><code>.setDescription(\"Click here\")</code> adds a descriptive text below the title</li> <li>The result shows the user's input and sends it back as a formatted message</li> </ul> <pre><code>@InlineHandler\nvoid inline(BotContext context, InlineQuery query){\n    if (query.query().equals(\"\")){\n        // Create a result for empty queries\n        var result = new InlineQueryResultArticle(\n            \"1\", // Unique identifier for this result\n            \"Write something\", // Title shown to the user\n            new InputTextMessageContent(\"Write something\") // Content that will be sent\n        );\n        // Send the result to the user\n        context.answerInlineQuery(query.id, new InlineQueryResult[]{result}).exec();\n    } else {\n        // Create a result that echoes the user's input\n        var result = new InlineQueryResultArticle(\n            \"2\", // Unique identifier\n            query.getQuery(), // Title shows the user's query\n            new InputTextMessageContent(\"&lt;b&gt;You said:&lt;/b&gt; \" + query.getQuery())\n                .setParseMode(ParseMode.HTML)\n        )\n            .setDescription(\"Click here\").build(); // Optional description below the title\n\n        // Send the result\n        context.answerInlineQuery(query.getId(), new InlineQueryResult[]{result}).exec();\n\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>else</code> block acts as a catch all for all inline queries (after the empty query handler)</li> <li><code>query.query</code> contains the text the user typed after the bot's username</li> <li><code>InputTextMessageContent()</code> creates formatted message content with HTML parsing</li> <li><code>.description(\"Click here\")</code> adds a descriptive text below the title</li> <li>The result shows the user's input and sends it back as a formatted message</li> </ul> <p>User Experience: When users type <code>@botusername some text</code>, they see a result that says \"some text\" and can send a message saying \"You said: some text\".</p>"},{"location":"examples/inline_bot/#_1","title":"","text":"<p>Final Complete Code</p> MethodAnnotation <pre><code>public class InlineBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\");\n        final var bot = new BotClient(TOKEN);\n\n        // Handle /start command with inline button\n        bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n            var keyboard = new InlineKeyboardMarkup(new InlineKeyboardButton[]{\n                    new InlineKeyboardButton(\"Try Inline Mode\").switchInlineQueryCurrentChat(\"\")\n            });\n            context.sendMessage(message.getChat().getId(), \"Hi! I am an inline bot. Press the button below to try inline mode\")\n                    .replyMarkup(keyboard)\n                    .exec();\n        });\n\n        // Handle empty inline queries (@botusername without text)\n        bot.onInline(filter -&gt; filter.emptyQuery(), (context, query) -&gt; {\n            var result = new InlineQueryResultArticle(\n                    \"1\",\n                    \"Write something\",\n                    new InputTextMessageContent(\"Write something\")\n            );\n            context.answerInlineQuery(query.id(), new InlineQueryResult[]{result}).exec();\n        });\n\n        // Handle inline queries with text (@botusername some text)\n        bot.onInline(_ -&gt; true, (context, query) -&gt; {\n            var result = new InlineQueryResultArticle(\n                    \"2\",\n                    query.query,\n                    new InputTextMessageContent(\"&lt;b&gt;You said:&lt;/b&gt; \" + query.query).parseMode(ParseMode.HTML)\n            ).description(\"Click here\");\n            context.answerInlineQuery(query.id, new InlineQueryResult[]{result}).exec();\n        });\n\n        bot.startPolling();\n    }\n}\n</code></pre> <pre><code>public class InlineBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\");\n        final var bot = new BotClient(TOKEN);\n\n        bot.addHandler(new InlineBot());\n        bot.startPolling();\n    }\n\n    @MessageHandler(commands = \"start\")\n    void start(BotContext context, Message message){\n        // Create an inline keyboard with a button that opens inline mode\n        var keyboard = new InlineKeyboardMarkup(new InlineKeyboardButton[]{\n            new InlineKeyboardButton(\"Inline\").switchInlineQueryCurrentChat(\"\")\n        });\n\n        // Send welcome message with the inline button\n        context.sendMessage(message.getChat().getId(), \"Hi! I am an inline bot. Press the button below to try inline mode\")\n                .replyMarkup(keyboard) // Attach the inline keyboard\n                .exec();\n    }\n\n    @InlineHandler\n    void inline(BotContext context, InlineQuery query){\n        if (query.query.equals(\"\")){\n            // Create a result for empty queries\n            var result = new InlineQueryResultArticle(\n                \"1\", // Unique identifier for this result\n                \"Write something\", // Title shown to the user\n                new InputTextMessageContent(\"Write something\") // Content that will be sent\n            );\n            // Send the result to the user\n            context.answerInlineQuery(query.id, new InlineQueryResult[]{result}).exec();\n        } else {\n            // Create a result that echoes the user's input\n            var result = new InlineQueryResultArticle(\n                \"2\", // Unique identifier\n                query.query, // Title shows the user's query\n                new InputTextMessageContent(\"&lt;b&gt;You said:&lt;/b&gt; \" + query.query).parseMode(ParseMode.HTML)\n            ).description(\"Click here\"); // Optional description below the title\n\n            // Send the result\n            context.answerInlineQuery(query.id, new InlineQueryResult[]{result}).exec();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/inline_bot/#how-inline-mode-works","title":"How Inline Mode Works","text":"<ol> <li>User types <code>/start</code> \u2192 Bot sends message with inline button</li> <li>User presses button \u2192 Telegram opens inline mode in current chat</li> <li>User types query \u2192 Bot receives inline query and returns results</li> <li>User selects result \u2192 Bot's message is sent to the chat</li> </ol> <p>Alternatively, users can directly type <code>@botusername query</code> in any chat to use inline mode.</p> <p>The full source code can be found on examples/inline_bot</p>"},{"location":"examples/inline_keyboard_bot/","title":"Inline Keyboard Bot","text":"<p>In this example, we will create a bot that uses inline keyboards - interactive buttons that appear within messages and can trigger actions without sending visible messages to the chat.</p>"},{"location":"examples/inline_keyboard_bot/#overview","title":"Overview","text":"<p>This bot demonstrates how to:</p> <ul> <li>Create and display inline keyboards with custom callback buttons</li> <li>Handle callback queries when users press inline buttons</li> <li>Update message content dynamically in response to user interactions</li> <li>Use emojis and HTML formatting for enhanced user experience</li> </ul> <p>We will use two types of handlers:</p> <ul> <li><code>onMessage</code> or <code>@MessageHandler</code> for handling the <code>/start</code> command and displaying the inline keyboard</li> <li><code>onCallback</code> or <code>@CallbackHandler</code> for handling user interactions with the inline buttons</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.annotations.MessageHandler;\nimport io.github.natanimn.telebof.types.annotations.CallbackHandler;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\n</code></pre> <p>Create <code>InlineKeyboardBot</code> class and initialize <code>BotClient</code></p> MethodAnnotation <pre><code>public class InlineKeyboardBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\"); // Get bot token from environment variable\n        final var bot = new BotClient(TOKEN); // Initialize bot client\n\n        // Add handlers here\n\n        bot.startPolling(); // Start the bot\n    }\n }\n</code></pre> <pre><code>public class InlineKeyboardBot {\n    public static void main(String[] args){\n        final var TOKEN = System.getenv(\"TOKEN\"); // Get bot token from environment variable\n        final var bot = new BotClient(TOKEN); // Initialize bot client\n\n        bot.addHandler(new InlineKeyboardBot());\n\n        bot.startPolling(); // Start the bot\n    }\n}\n</code></pre>"},{"location":"examples/inline_keyboard_bot/#message-handler-with-inline-keyboard","title":"Message Handler with Inline Keyboard","text":"<p>Add <code>/start</code> handler that creates and displays an inline keyboard</p> MethodAnnotation <pre><code>bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n    // Create an inline keyboard markup\n    var keyboard = new InlineKeyboardMarkup();\n\n    // Add buttons with emojis and callback data\n    keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe9 Green\", \"color-green\"));\n    keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe8 Yellow\", \"color-yellow\"));\n    keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe5 Red\", \"color-red\"));\n\n    // Send message with inline keyboard attached\n    context.sendMessage(message.chat.id, \"Press one of the following inline buttons: \")\n            .replyMarkup(keyboard) // Attach the inline keyboard to the message\n            .exec();\n});\n</code></pre> <pre><code> @MessageHandler(commands = \"start\")\n void start(BotContext context, Message message)  {\n     // Create an inline keyboard markup\n     var keyboard = new InlineKeyboardMarkup();\n\n     // Add buttons with emojis and callback data\n     keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe9 Green\", \"color-green\"));\n     keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe8 Yellow\", \"color-yellow\"));\n     keyboard.addKeyboard(new InlineKeyboardButton(\"\ud83d\udfe5 Red\", \"color-red\"));\n\n     // Send message with inline keyboard attached\n     context.sendMessage(message.chat.id, \"Press one of the following inline buttons: \")\n             .replyMarkup(keyboard) // Attach the inline keyboard to the message\n             .exec();\n }\n</code></pre> <p>Explanation:</p> <ul> <li><code>InlineKeyboardMarkup()</code> creates an inline keyboard that appears below the message content</li> </ul> <p>Each <code>InlineKeyboardButton</code> takes two parameters:</p> <ol> <li>Text: The visible label on the button (includes color emojis: \ud83d\udfe9, \ud83d\udfe8, \ud83d\udfe5)</li> <li>Callback Data: A unique identifier sent when the button is pressed (<code>color-green</code>, <code>color-yellow</code>, <code>color-red</code>)</li> </ol> <ul> <li><code>addKeyboard()</code> adds each button on a separate row</li> <li><code>replyMarkup(keyboard)</code> attaches the inline keyboard to the message</li> </ul> <p>Visual Result: The user sees a message with three colorful buttons below it that they can interact with.</p> <p></p>"},{"location":"examples/inline_keyboard_bot/#callback-query-handler","title":"Callback Query Handler","text":"<p>Add handler to process inline button presses</p> MethodAnnotation <pre><code>bot.onCallback(filter -&gt; filter.regex(\"color-\"), (context, callback) -&gt; {\n    // Immediately acknowledge the callback query\n    // This removes the loading indicator from the button\n    context.answerCallbackQuery(callback.id).exec();\n\n    // Extract the color name from the callback data\n    // Example: \"color-green\" \u2192 \"green\"\n    var color = callback.data.split(\"-\")[1];\n\n    // Create an appropriate response message based on the button pressed\n    String response = switch (color) {\n        case \"green\" -&gt; \"You have pressed &lt;b&gt;Green&lt;/b&gt; button!\";\n        case \"yellow\" -&gt; \"You have pressed &lt;b&gt;Yellow&lt;/b&gt; button!\";\n        case \"red\" -&gt; \"You have pressed &lt;b&gt;Red&lt;/b&gt; button\";\n        default -&gt; \"You have pressed &lt;b&gt;Unknown&lt;/b&gt; button\";\n    };\n\n    // Edit the original message to show which button was pressed\n    context.editMessageText(response, callback.message.chat.id, callback.message.message_id)\n            .parseMode(ParseMode.HTML) // Use HTML formatting for bold text\n            .replyMarkup(callback.message.reply_markup) // Keep the same keyboard\n            .exec();\n});\n</code></pre> <pre><code>@CallbackHandler(regex = \"color-\")\nvoid button(BotContext context, Message message){\n   // Immediately acknowledge the callback query\n   // This removes the loading indicator from the button\n   context.answerCallbackQuery(callback.id).exec();\n\n   // Extract the color name from the callback data\n   // Example: \"color-green\" \u2192 \"green\"\n   var color = callback.data.split(\"-\")[1];\n\n   // Create an appropriate response message based on the button pressed\n   String response = switch (color) {\n      case \"green\" -&gt; \"You have pressed &lt;b&gt;Green&lt;/b&gt; button!\";\n      case \"yellow\" -&gt; \"You have pressed &lt;b&gt;Yellow&lt;/b&gt; button!\";\n      case \"red\" -&gt; \"You have pressed &lt;b&gt;Red&lt;/b&gt; button\";\n      default -&gt; \"You have pressed &lt;b&gt;Unknown&lt;/b&gt; button\";\n   };\n\n   // Edit the original message to show which button was pressed\n   context.editMessageText(response, callback.message.chat.id, callback.message.message_id)\n           .parseMode(ParseMode.HTML) // Use HTML formatting for bold text\n           .replyMarkup(callback.message.reply_markup) // Keep the same keyboard\n           .exec();\n}\n</code></pre> <p>Explanation:</p> <p>Callback Query Acknowledgment:</p> <ul> <li><code>answerCallbackQuery(callback.id).exec()</code> is required to tell Telegram the button press was received</li> <li>This removes the loading animation from the pressed button</li> </ul> <p>Callback Data Processing:</p> <ul> <li><code>filter.regex(\"color-\")</code> matches any callback data starting with \"color-\"</li> <li>The callback data is split to extract the specific color identifier</li> </ul> <p>Message Editing:</p> <ul> <li><code>editMessageText()</code> modifies the existing message instead of sending a new one</li> <li>This provides a cleaner user experience by updating the original message</li> <li><code>replyMarkup(callback.message.reply_markup)</code> preserves the original keyboard layout</li> </ul> <p>User Feedback:</p> <ul> <li>The message content changes to provide immediate feedback about which button was pressed</li> <li>HTML formatting (<code>&lt;b&gt;...&lt;/b&gt;</code>) makes the response more visually appealing</li> </ul>"},{"location":"examples/inline_keyboard_bot/#complete-workflow","title":"Complete Workflow","text":"<ol> <li>User sends <code>/start</code> \u2192 Bot displays message with three inline buttons (Green, Yellow, Red)</li> <li>User presses a button \u2192 Telegram sends a callback query to the bot</li> <li>Bot processes callback \u2192 </li> <li>Acknowledges the query (removes button loading state)</li> <li>Determines which button was pressed</li> <li>Updates the original message to show the selection</li> <li>User sees updated message \u2192 The message now indicates which button was chosen</li> </ol>"},{"location":"examples/inline_keyboard_bot/#summary","title":"Summary","text":"<p>This example demonstrates how to implement interactive inline keyboards that:</p> <ul> <li>Provide clean user interactions without cluttering the chat</li> <li>Offer immediate visual feedback when buttons are pressed</li> <li>Maintain message context by editing existing messages instead of creating new ones</li> <li>Use semantic callback data to identify user actions meaningfully</li> <li>Enhance user experience with emojis and formatted text</li> </ul> <p>The full source code can be found on examples/inline_keybaord_bot</p>"},{"location":"examples/keyboard_bot/","title":"Keyboard Bot","text":"<p>In this example, we will create a bot that uses a custom reply keyboard to interact with users. The bot will present buttons for the user to press, and respond with information based on their selection.</p> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.types.keyboard.ReplyKeyboardMarkup;\nimport io.github.natanimn.telebof.enums.ParseMode;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.keyboard.ReplyKeyboardMarkup;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.annotations.MesageHandler;\n</code></pre> <p>Create <code>KeyboardBot</code> class and initialize <code>BotClient</code> with a <code>token</code></p> <pre><code>public class KeyboardBot {\n    public static void main(String[] args) {\n        final String TOKEN = \"BOT_TOKEN\"; // Replace with your actual bot token\n        var bot = new BotClient(TOKEN);\n\n        // Add handlers here\n\n        // Start the bot\n        bot.startPolling();\n    }\n}\n</code></pre> <p>Our bot will present a keyboard with three buttons and respond appropriately when they are pressed:</p> <ul> <li>ID - Shows the user's Telegram ID</li> <li>Username - Shows the user's username (if available)</li> <li>Language - Shows the user's language code</li> </ul> <p>Add <code>/start</code> handler with reply keyboard</p> <p>The <code>/start</code> command initializes the conversation and displays the custom keyboard to the user.</p> MethodAnnotation <pre><code>bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n    // Create a reply keyboard with resize option for better mobile appearance\n    var keyboard = new ReplyKeyboardMarkup().resizeKeyboard(true);\n\n    // Add buttons to the keyboard (in a single row by default)\n    keyboard.add(\"ID\", \"Username\", \"Language\");\n\n    // Send welcome message with the keyboard attached\n    context.sendMessage(message.chat.id, \"Welcome! Please choose an option:\")\n           .replyMarkup(keyboard) // Attach the keyboard to the message\n           .exec();\n});\n</code></pre> <pre><code>@MessageHandler(commands = \"start\")\nvoid start(BotContext context, Message message){\n\n    // Create a reply keyboard with resize option for better mobile appearance\n    var keyboard = new ReplyKeyboardMarkup().resizeKeyboard(true);\n\n    // Add buttons to the keyboard (in a single row by default)\n    keyboard.add(\"ID\", \"Username\", \"Language\");\n\n    // Send welcome message with the keyboard attached\n    context.sendMessage(message.chat.id, \"Welcome! Please choose an option:\")\n            .replyMarkup(keyboard) // Attach the keyboard to the message\n            .exec();\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>ReplyKeyboardMarkup()</code> creates a custom keyboard.</li> <li><code>resizeKeyboard(true)</code> makes the buttons compact and small sized.</li> <li><code>keyboard.add()</code> adds buttons to the keyboard. Multiple buttons in one <code>add()</code> call will appear on the same row.</li> <li><code>replyMarkup(keyboard)</code> attaches the custom keyboard to the message.</li> </ul> <p>Result without <code>replyMarkup</code>:</p> <p></p> <p>Result with <code>replyMarkup</code> but without <code>resizeKeyboard</code>:</p> <p></p> <p>Final result with both <code>replyMarkup</code> and <code>resizeKeyboard(true)</code>:</p> <p></p> <p>Add handler to respond to keyboard button presses</p> <p>When a user presses any of the custom keyboard buttons, Telegram sends the button text as a regular message. We use the <code>filter.texts()</code> method to capture these specific messages.</p> MethodAnnotation <pre><code>bot.onMessage(filter -&gt; filter.texts(\"ID\", \"Username\", \"Language\"), (context, message) -&gt; {\n    var user = message.from;\n    String response;\n\n    switch (message.text) {\n        case \"ID\":\n            response = String.format(\"&lt;b&gt;Your ID is:&lt;/b&gt; &lt;code&gt;%d&lt;/code&gt;\", user.id);\n            break;\n\n        case \"Username\":\n            if (user.username == null) {\n                response = \"&lt;i&gt;You don't have a username set in your Telegram profile.&lt;/i&gt;\";\n            } else {\n                response = String.format(\"&lt;b&gt;Your username is:&lt;/b&gt; @%s\", user.username);\n            }\n            break;\n\n        case \"Language\":\n            String language = (user.language_code != null) ? user.language_code : \"not specified\";\n            response = String.format(\"&lt;b&gt;Your language code is:&lt;/b&gt; %s\", language);\n            break;\n\n        default:\n            response = \"Unknown option selected.\";\n    }\n\n    context.sendMessage(message.chat.id, response)\n           .parseMode(ParseMode.HTML)\n           .exec();\n});\n</code></pre> <p>Explanation:</p> <ul> <li><code>filter.texts(\"ID\", \"Username\", \"Language\")</code> captures messages that exactly match these button texts. </li> <li>We use a switch statement for cleaner control flow when handling multiple button options.</li> <li>The response is formatted using HTML for better presentation (bold text, code formatting for ID).</li> <li>We handle edge cases like missing username or language code gracefully.</li> </ul> <p><pre><code>@MessageHandler(texts = {\"ID\", \"Username\", \"Language\"})\nvoid text(BotContext context, Message message){\n    var user = message.from;\n    String response;\n\n    switch (message.text) {\n        case \"ID\":\n            response = String.format(\"&lt;b&gt;Your ID is:&lt;/b&gt; &lt;code&gt;%d&lt;/code&gt;\", user.id);\n            break;\n\n        case \"Username\":\n            if (user.username == null) {\n                response = \"&lt;i&gt;You don't have a username set in your Telegram profile.&lt;/i&gt;\";\n            } else {\n                response = String.format(\"&lt;b&gt;Your username is:&lt;/b&gt; @%s\", user.username);\n            }\n            break;\n\n        case \"Language\":\n            String language = (user.language_code != null) ? user.language_code : \"not specified\";\n            response = String.format(\"&lt;b&gt;Your language code is:&lt;/b&gt; %s\", language);\n            break;\n\n        default:\n            response = \"Unknown option selected.\";\n    }\n\n    context.sendMessage(message.chat.id, response)\n            .parseMode(ParseMode.HTML)\n            .exec();\n    }\n</code></pre> Explanation:</p> <ul> <li><code>texts = {\"ID\", \"Username\", \"Language\"}</code> captures messages that exactly match these button texts. </li> <li>We use a switch statement for cleaner control flow when handling multiple button options.</li> <li>The response is formatted using HTML for better presentation (bold text, code formatting for ID).</li> <li>We handle edge cases like missing username or language code gracefully.</li> </ul> <p>Finally, add the class ```java bot.addHandler(new KeyboardBot());</p> <p>Final Complete Code</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.types.keyboard.ReplyKeyboardMarkup;\nimport io.github.natanimn.telebof.enums.ParseMode;\n\npublic class KeyboardBot {\n    public static void main(String[] args) {\n        final String TOKEN = \"BOT_TOKEN\"; // Replace with your actual bot token\n        var bot = new BotClient(TOKEN);\n\n        // Handle /start command with keyboard\n        bot.onMessage(filter -&gt; filter.commands(\"start\"), (context, message) -&gt; {\n            var keyboard = new ReplyKeyboardMarkup().resizeKeyboard(true);\n            keyboard.add(\"ID\", \"Username\", \"Language\");\n\n            context.sendMessage(message.chat.id, \"Welcome! Please choose an option:\")\n                   .replyMarkup(keyboard)\n                   .exec();\n        });\n\n        // Handle keyboard button presses\n        bot.onMessage(filter -&gt; filter.texts(\"ID\", \"Username\", \"Language\"), (context, message) -&gt; {\n            var user = message.from;\n            String response;\n\n            switch (message.text) {\n                case \"ID\":\n                    response = String.format(\"&lt;b&gt;Your ID is:&lt;/b&gt; &lt;code&gt;%d&lt;/code&gt;\", user.id);\n                    break;\n                case \"Username\":\n                    if (user.username == null) {\n                        response = \"&lt;i&gt;You don't have a username set.&lt;/i&gt;\";\n                    } else {\n                        response = String.format(\"&lt;b&gt;Your username is:&lt;/b&gt; @%s\", user.username);\n                    }\n                    break;\n                case \"Language\":\n                    String language = (user.language_code != null) ? user.language_code : \"not specified\";\n                    response = String.format(\"&lt;b&gt;Your language code is:&lt;/b&gt; %s\", language);\n                    break;\n                default:\n                    response = \"Unknown option.\";\n            }\n\n            context.sendMessage(message.chat.id, response)\n                   .parseMode(ParseMode.HTML)\n                   .exec();\n        });\n\n        // Start the bot\n        bot.startPolling();\n    }\n}\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.keyboard.ReplyKeyboardMarkup;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.annotations.MesageHandler;\n\npublic class KeyboardBot {\n    public static void main(String[] args) {\n        final String TOKEN = \"BOT_TOKEN\"; // Replace with your actual bot token\n        var bot = new BotClient(TOKEN);\n\n        // Add the class    \n        bot.addHandler(this);\n\n        // Start the bot\n        bot.startPolling();\n    }\n\n    @MessageHandler(commands = \"start\")\n    void start(BotContext context, Message message){\n\n        // Create a reply keyboard with resize option for better mobile appearance\n        var keyboard = new ReplyKeyboardMarkup().resizeKeyboard(true);\n\n        // Add buttons to the keyboard (in a single row by default)\n        keyboard.add(\"ID\", \"Username\", \"Language\");\n\n        // Send welcome message with the keyboard attached\n        context.sendMessage(message.chat.id, \"Welcome! Please choose an option:\")\n                .replyMarkup(keyboard) // Attach the keyboard to the message\n                .exec();\n    }\n\n    @MessageHandler(texts = {\"ID\", \"Username\", \"Language\"})\n    void text(BotContext context, Message message){\n        var user = message.from;\n        String response;\n\n        switch (message.text) {\n            case \"ID\":\n                response = String.format(\"&lt;b&gt;Your ID is:&lt;/b&gt; &lt;code&gt;%d&lt;/code&gt;\", user.id);\n                break;\n\n            case \"Username\":\n                if (user.username == null) {\n                    response = \"&lt;i&gt;You don't have a username set in your Telegram profile.&lt;/i&gt;\";\n                } else {\n                    response = String.format(\"&lt;b&gt;Your username is:&lt;/b&gt; @%s\", user.username);\n                }\n                break;\n\n            case \"Language\":\n                String language = (user.language_code != null) ? user.language_code : \"not specified\";\n                response = String.format(\"&lt;b&gt;Your language code is:&lt;/b&gt; %s\", language);\n                break;\n\n            default:\n                response = \"Unknown option selected.\";\n        }\n\n        context.sendMessage(message.chat.id, response)\n                .parseMode(ParseMode.HTML)\n                .exec();\n    }\n}\n</code></pre> <p>Summary</p> <p>This bot demonstrates how to:</p> <ul> <li>Create and display a custom reply keyboard with <code>ReplyKeyboardMarkup</code></li> <li>Use <code>resizeKeyboard(true)</code> for better appearance</li> <li>Handle button presses by filtering specific message texts</li> <li>Respond with user information in formatted HTML messages</li> <li>Gracefully handle edge cases like missing user data</li> </ul> <p>The full source code can be found on examples/keyboard_bot</p> <p>Final result showing the interaction flow: </p>"},{"location":"examples/media_downloader/","title":"Media Downloader Bot","text":"<p>In this example section, we will create a bot that downloads media files (photos, videos, GIFs, audio) sent by users, stores them locally, and allows users to retrieve them using special commands. This bot demonstrates file handling, custom filters, and media processing capabilities.</p> <p>We will use different types of handlers and features:</p> <ul> <li><code>onMessage</code> for handling commands and media messages</li> <li><code>CustomFilter</code> for validating special retrieval commands</li> <li>File download and upload operations</li> <li>Multi threading for efficient media processing</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.filters.CustomFilter;\nimport io.github.natanimn.telebof.types.ReplyParameters;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.updates.Update;\nimport java.io.FileOutputStream;\nimport java.io.File;\nimport java.util.Arrays;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.filters.CustomFilter;\nimport io.github.natanimn.telebof.types.ReplyParameters;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.updates.Update;\nimport io.github.natanimn.telebof.annotations.MessageHandler;\nimport io.github.natanimn.telebof.enums.MessageType;\nimport java.io.FileOutputStream;\nimport java.io.File;\nimport java.util.Arrays;\n</code></pre>"},{"location":"examples/media_downloader/#custom-filter-for-command-validation","title":"Custom Filter for Command Validation","text":"<p>Create <code>IsValidCommand</code> class to validate media retrieval commands</p> <p>This filter ensures that commands follow the pattern <code>/type_fileId</code> where type is one of: photo, video, gif, or audio.</p> <pre><code>class IsValidCommand implements CustomFilter{\n    @Override\n    public boolean check(Update update) {\n        var text = update.message.text;\n        if (!text.startsWith(\"/\")) return false;\n\n        var params = text.split(\"_\");\n\n        if (params.length == 1) return false;\n\n        var prefix = params[0];\n        var commands = new String[]{\"/photo\", \"/video\", \"/gif\", \"/audio\"};\n\n        return Arrays.stream(commands).toList().contains(prefix);\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Checks if the message starts with \"/\" and contains underscores</li> <li>Validates that the command prefix is one of the supported media types</li> <li>Ensures proper command format for media retrieval</li> </ul> <p>Let us create <code>MediaDownloader</code> class with a constructor and initialize <code>BotClient</code> with 10 threads for better performance</p> MethodAnnotation <pre><code>public class MediaDownloader {\n    private BotClient bot;\n\n    public MediaDownloader(String token){\n        // Initialize bot with 10 threads for concurrent media processing\n        this.bot = new BotClient.Builder(token).numThreads(10).build();\n\n        var isValidCommand = new IsValidCommand();\n\n        // Register handlers\n        bot.onMessage(filter -&gt; filter.commands(\"start\"), this::start);\n        bot.onMessage(filter -&gt; filter.photo() || filter.animation() || filter.video() || filter.audio(), this::downloadMedia);\n        bot.onMessage(filter -&gt; filter.text() &amp;&amp; filter.customFilter(isValidCommand), this::getMedia);\n    }\n}\n</code></pre> <pre><code>public class MediaDownloader {\n    private BotClient bot;\n\n    public MediaDownloader(String token){\n        // Initialize bot with 10 threads for concurrent media processing\n        this.bot = new BotClient.Builder(token).numThreads(10).build();\n\n        // Register the class as a handler\n        bot.addHandler(this);\n    }\n}\n</code></pre> <p>Our bot will be handling the following events:</p> <ul> <li><code>/start</code> command - Welcome message and instructions</li> <li>Media messages (photos, videos, GIFs, audio) - Download and storage</li> <li>Special retrieval commands (<code>/photo_fileId</code>, <code>/video_fileId</code>, etc.) - Media retrieval</li> </ul> <p>Create <code>/start</code> handler with welcome message</p> MethodAnnotation <pre><code>private void start(BotContext context, Message message){\n    context.sendMessage(message.chat.id,\n    \"\"\"\n    Welcome!\n    I am media downloader bot. Send me photo, video, audio or gif up to 20MB;\n    I will download it into my machine, and you will get it back with special command\"\"\").exec();\n}\n</code></pre> <pre><code>@MessageHandler(commands = \"start\")\nprivate void start(BotContext context, Message message){\n    context.sendMessage(message.chat.id,\n    \"\"\"\n    Welcome! \n    I am media downloader bot. Send me photo, video, audio or gif up to 20MB; \n    I will download it into my machine, and you will get it back with special command\"\"\").exec();\n}\n</code></pre>"},{"location":"examples/media_downloader/#_1","title":"Media Downloader","text":"<p>Handle media download when user sends photos, videos, GIFs, or audio</p> <p>This handler processes incoming media files, downloads them from Telegram servers, and stores them locally.</p> MethodAnnotation <pre><code>private void downloadMedia(BotContext context, Message message) {\n\n    // Send initial processing message as a reply to the media\n    var msg = context.sendMessage(message.chat.id, \"&lt;code&gt;Downloading media...&lt;/code&gt;\")\n            .replyParameters(new ReplyParameters(message.message_id))\n            .parseMode(ParseMode.HTML)\n            .exec();\n\n    String file_id, type, ext;\n\n    // Determine media type and get the appropriate file ID\n    if (message.photo != null) {\n        file_id = message.photo.getLast().file_id; // Get highest quality photo\n        type    = \"photo\";\n        ext     = \".png\";\n    } else if (message.audio != null) {\n        file_id = message.audio.file_id;\n        type    = \"audio\";\n        ext     = \".mp3\";\n    } else if (message.video != null) {\n        file_id = message.video.file_id;\n        type    = \"video\";\n        ext     = \".mp4\";\n    } else {\n        file_id = message.animation.file_id;\n        type = \"gif\";\n        ext = \".gif\";\n    }\n\n    // Get file information and download the actual file content\n    var file    = context.getFile(file_id).exec();\n    byte[] data = context.downloadFile(file.file_path);\n\n    // Save the downloaded file to local storage\n    try(var stream  = new FileOutputStream(file_id + ext)){\n        stream.write(data);\n\n        // Update status message to indicate success\n        context.editMessageText(\"&lt;b&gt;Media downloaded successfully!&lt;/b&gt;\", message.chat.id, msg.message_id)\n                .parseMode(ParseMode.HTML)\n                .exec();\n\n        // Provide the user with the command to retrieve this media later\n        context.sendMessage(message.chat.id, String.format(\"Send &lt;code&gt;/%s_%s&lt;/code&gt; to get the media back\", type, file_id))\n                .parseMode(ParseMode.HTML)\n                .exec();\n    } catch (Exception e) {\n        // Handle any errors during the download process\n        context.editMessageText(\"An error occurred:\\n\\n\" + e.getMessage(), message.chat.id, msg.message_id).exec();\n    }\n}\n</code></pre> <pre><code>@MessageHandler(type = {MessageType.PHOTO, MessageType.VIDEO, MessageType.AUDIO, MessageType.ANIMATION})\nprivate void downloadMedia(BotContext context, Message message) {\n\n    // Send initial processing message as a reply to the media\n    var msg = context.sendMessage(message.chat.id, \"&lt;code&gt;Downloading media...&lt;/code&gt;\")\n            .replyParameters(new ReplyParameters(message.message_id))\n            .parseMode(ParseMode.HTML)\n            .exec();\n\n    String file_id, type, ext;\n\n    // Determine media type and get the appropriate file ID\n    if (message.photo != null) {\n        file_id = message.photo.getLast().file_id; // Get highest quality photo\n        type    = \"photo\";\n        ext     = \".png\";\n    } else if (message.audio != null) {\n        file_id = message.audio.file_id;\n        type    = \"audio\";\n        ext     = \".mp3\";\n    } else if (message.video != null) {\n        file_id = message.video.file_id;\n        type    = \"video\";\n        ext     = \".mp4\";\n    } else {\n        file_id = message.animation.file_id;\n        type = \"gif\";\n        ext = \".gif\";\n    }\n\n    // Get file information and download the actual file content\n    var file    = context.getFile(file_id).exec();\n    byte[] data = context.downloadFile(file.file_path);\n\n    // Save the downloaded file to local storage\n    try(var stream  = new FileOutputStream(file_id + ext)){\n        stream.write(data);\n\n        // Update status message to indicate success\n        context.editMessageText(\"&lt;b&gt;Media downloaded successfully!&lt;/b&gt;\", message.chat.id, msg.message_id)\n                .parseMode(ParseMode.HTML)\n                .exec();\n\n        // Provide the user with the command to retrieve this media later\n        context.sendMessage(message.chat.id, String.format(\"Send &lt;code&gt;/%s_%s&lt;/code&gt; to get the media back\", type, file_id))\n                .parseMode(ParseMode.HTML)\n                .exec();\n    } catch (Exception e) {\n        // Handle any errors during the download process\n        context.editMessageText(\"An error occurred:\\n\\n\" + e.getMessage(), message.chat.id, msg.message_id).exec();\n    }\n}\n</code></pre> <p>The above code explanation goes as the following:</p> <pre><code>if (message.photo != null) {\n    file_id = message.photo.getLast().file_id; // Get highest quality photo\n    type    = \"photo\";\n    ext     = \".png\";\n}\n</code></pre> <p>This section handles photos by selecting the last (and highest quality) version from the available photo sizes array.</p> <pre><code>var file    = context.getFile(file_id).exec();\nbyte[] data = context.downloadFile(file.file_path);\n</code></pre> <p>These lines retrieve file information from Telegram and download the actual file content using the file path.</p> <pre><code>try(var stream  = new FileOutputStream(file_id + ext)){\n    stream.write(data);\n</code></pre> <p>This saves the downloaded media to a local file with the appropriate extension.</p> <pre><code>context.sendMessage(message.chat.id, String.format(\"Send &lt;code&gt;/%s_%s&lt;/code&gt; to get the media back\", type, file_id))\n</code></pre> <p>This provides the user with a specific command they can use later to retrieve this exact media file.</p>"},{"location":"examples/media_downloader/#_2","title":"Media Downloader","text":"<p>Handle media retrieval using special commands</p> <p>This handler processes commands in the format <code>/type_fileId</code> and sends back the corresponding media file.</p> MethodAnnotation <pre><code>private void getMedia(BotContext context, Message message) {\n    var param = message.text.split(\"_\");\n    var type = param[0].replace(\"/\", \"\"); // Extract media type from command\n    var file_id = String.join(\"_\", Arrays.copyOfRange(param, 1, param.length)); // Reconstruct file ID\n    var chat_id = message.chat.id;\n\n    // Determine the correct file extension based on media type\n    File file = switch (type){\n        case \"photo\" -&gt; new File(file_id + \".png\");\n        case \"video\" -&gt; new File(file_id + \".mp4\");\n        case \"gif\" -&gt; new File(file_id + \".gif\");\n        default -&gt; new File(file_id + \".mp3\"); // audio\n    };\n\n    if (file.exists()){\n        // Send the appropriate media type based on the command\n        switch (type){\n            case \"photo\":\n                context.sendPhoto(chat_id, file).exec();\n                break;\n            case \"video\":\n                context.sendVideo(chat_id, file).exec();\n                break;\n            case \"gif\":\n                context.sendAnimation(chat_id, file).exec();\n                break;\n            default: // audio\n                context.sendAudio(chat_id, file).exec();\n                break;\n        }\n    } else {\n        context.sendMessage(chat_id, \"Media not found\").exec();\n    }\n}\n</code></pre> <pre><code>@MessageHandler(type = MessageType.TEXT, filter = IsValidCommand.class)\nprivate void getMedia(BotContext context, Message message) {\n    var param = message.text.split(\"_\");\n    var type = param[0].replace(\"/\", \"\"); // Extract media type from command\n    var file_id = String.join(\"_\", Arrays.copyOfRange(param, 1, param.length)); // Reconstruct file ID\n    var chat_id = message.chat.id;\n\n    // Determine the correct file extension based on media type\n    File file = switch (type){\n        case \"photo\" -&gt; new File(file_id + \".png\");\n        case \"video\" -&gt; new File(file_id + \".mp4\");\n        case \"gif\" -&gt; new File(file_id + \".gif\");\n        default -&gt; new File(file_id + \".mp3\"); // audio\n    };\n\n    if (file.exists()){\n        // Send the appropriate media type based on the command\n        switch (type){\n            case \"photo\":\n                context.sendPhoto(chat_id, file).exec();\n                break;\n            case \"video\":\n                context.sendVideo(chat_id, file).exec();\n                break;\n            case \"gif\":\n                context.sendAnimation(chat_id, file).exec();\n                break;\n            default: // audio\n                context.sendAudio(chat_id, file).exec();\n                break;\n        }\n    } else {\n        context.sendMessage(chat_id, \"Media not found\").exec();\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Parses commands like <code>/photo_BAACAgIAAxkBAAIlYmivZAV</code></li> <li>Reconstructs the original file ID from the command parameters</li> <li>Checks if the file exists in local storage</li> <li>Sends the appropriate media type back to the user</li> </ul> <p>Finally, create <code>runBot</code> method and run the bot</p> <pre><code>public void runBot(){\n    bot.startPolling();\n}\n\npublic static void main(String[] args){\n    final var TOKEN = System.getenv(\"TOKEN\");\n    final var downloader = new MediaDownloader(TOKEN);\n    downloader.runBot();\n}\n</code></pre> <p></p> <p>Our Media Downloader Bot can:</p> <ul> <li>Accept and process various media types (photos, videos, GIFs, audio)</li> <li>Download files from Telegram servers and store them locally</li> <li>Provide users with specific retrieval commands for each downloaded file</li> <li>Retrieve and send back stored media files on demand</li> <li>Handle multiple media processing operations concurrently using multiple threads</li> </ul> <p>The full source code can be found on examples/media_downloader</p>"},{"location":"examples/payment_bot/","title":"Payment Example Bot","text":"<p>In this example section, we will create a bot that demonstrates Telegram's Stars payment system. The bot will send invoices, process payments, and handle refunds, providing a complete workflow for handling monetary transactions.</p> <p>We will use two different types of handlers:</p> <ul> <li><code>onMessage</code> or <code>@MessageHandler</code> for handling commands (<code>/start</code>, <code>/pay</code>) and successful payment updates.</li> <li><code>onPreCheckout</code> or <code>@PreCheckoutHandler</code> for handling Precheckout queries (authorizing payments to proceed).</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.payments.LabeledPrice;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.updates.PreCheckoutQuery;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.enums.MessageType;\nimport io.github.natanimn.telebof.types.payments.LabeledPrice;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.updates.PreCheckoutQuery;\nimport io.github.natanimn.telebof.annotations.MessageHandler;\nimport io.github.natanimn.telebof.annotations.PreCheckoutHandler;\n</code></pre> <p>Let us create the <code>PaymentExampleBot</code> class and initialize the <code>BotClient</code> with a <code>token</code> from an environment variable</p> MethodAnnotation <pre><code>public class PaymentExampleBot {\n    static String TOKEN = System.getenv(\"TOKEN\");\n    public static void main(String[] args){\n        BotClient bot = new BotClient(TOKEN);\n        // Add handlers here\n    }\n}\n</code></pre> <pre><code>public class PaymentExampleBot {\n    static String TOKEN = System.getenv(\"TOKEN\");\n        public static void main(String[] args){\n            BotClient bot = new BotClient(TOKEN);\n            bot.addHandler(new PaymentExampleBot());\n            bot.startPolling();\n        }\n    }\n</code></pre> <p>Our bot will be handling the following events:</p> <ul> <li><code>/start</code> command</li> <li><code>/pay</code> command</li> <li>Precheckout queries (required step before payment is finalized)</li> <li>Successful payment updates</li> </ul> <p>Create <code>/start</code> handler</p> <p>When the user types <code>/start</code>, the bot responds with a welcome message explaining its purpose.</p> MethodAnnotation <pre><code>static void start(BotContext context, Message message){\n    var user = message.from;\n    context.sendMessage(message.chat.id, String.format(\n    \"&lt;b&gt;Hello %s!&lt;/b&gt;,\\n\\nI am payment example bot.\\n&lt;i&gt;Send /pay to try it out.&lt;/i&gt;\", user.mention()\n    ))\n    .parseMode(ParseMode.HTML)\n    .exec();\n}\n</code></pre> <pre><code>// Add in main method:\nbot.onMessage(filter -&gt; filter.commands(\"start\"), PaymentExampleBot::start);\n</code></pre> <pre><code>@MessageHandler(commands = \"start\")\nvoid start(BotContext context, Message message){\n    var user = message.from;\n    context.sendMessage(message.chat.id, String.format(\n            \"&lt;b&gt;Hello %s!&lt;/b&gt;,\\n\\nI am payment example bot.\\n&lt;i&gt;Send /pay to try it out.&lt;/i&gt;\", user.mention()\n    ))\n     .parseMode(ParseMode.HTML)\n     .exec();\n}\n</code></pre> <p></p> <p>Create <code>/pay</code> handler and send an invoice</p> <p>When the user types <code>/pay</code>, the bot sends an invoice for 10 Telegram Stars.</p> MethodAnnotation <pre><code>static void pay(BotContext context, Message message){\n    // Create a price object for 10 Telegram Stars\n    LabeledPrice price = new LabeledPrice(\"Pay 10 star\", 10);\n\n    /**\n     * Send an invoice with the following parameters:\n     * - chatId: The chat to send the invoice to\n     * - title: The title of the invoice\n     * - description: A description of what the user is paying for\n     * - payload: A unique identifier for this transaction (used for validation)\n     * - currency: \"XTR\" is the currency code for Telegram Stars\n     * - prices: An array of LabeledPrice objects defining the cost\n     */\n    context.sendInvoice(\n            message.chat.id,\n            \"Payment test\",\n            \"Pay 10 start for telebof payment test bot\",\n            \"pay-10\", // In a real application, this should be a unique value per transaction\n            \"XTR\",\n            new LabeledPrice[]{price}\n    ).exec();\n}\n</code></pre> <pre><code>// Add in main method:\nbot.onMessage(filter -&gt; filter.commands(\"pay\"), PaymentExampleBot::pay);\n</code></pre> <pre><code>@MessageHandler(commands = \"pay\")\nvoid pay(BotContext context, Message message){\n    // Create a price object for 10 Telegram Stars\n    LabeledPrice price = new LabeledPrice(\"Pay 10 star\", 10);\n\n    /**\n     * Send an invoice with the following parameters:\n     * - chatId: The chat to send the invoice to\n     * - title: The title of the invoice\n     * - description: A description of what the user is paying for\n     * - payload: A unique identifier for this transaction (used for validation)\n     * - currency: \"XTR\" is the currency code for Telegram Stars\n     * - prices: An array of LabeledPrice objects defining the cost\n     */\n    context.sendInvoice(\n            message.chat.id,\n            \"Payment test\",\n            \"Pay 10 start for telebof payment test bot\",\n            \"pay-10\", // In a real application, this should be a unique value per transaction\n            \"XTR\",\n            new LabeledPrice[]{price}\n    ).exec();\n}\n</code></pre> <p></p> <p>Handle PreCheckout Query</p> <p>After the user confirms payment in the invoice, Telegram sends a precheckout query to the bot. The bot must answer this query within a short time window to allow the payment to proceed or fail.</p> <p>This is a crucial step where you would typically:</p> <ol> <li>Validate the payment details (e.g., check item prices, ensure the <code>payload</code> is valid).</li> <li>Check if the items are still in stock.</li> <li>Based on this check, confirm or deny the payment.</li> </ol> <p>For this example, we automatically confirm all queries.</p> MethodAnnotation <pre><code>static void processPrecheckOut(BotContext context, PreCheckoutQuery query){\n    // Always confirm the checkout for this demo.\n    // In a real application, add your validation logic here and answer false if it fails.\n    context.answerPreCheckoutQuery(query.id, true).exec();\n}\n</code></pre> <pre><code>// Add in main method:\nbot.onPreCheckout(filter -&gt; true, PaymentExampleBot::processPrecheckOut);\n</code></pre> <pre><code>@PreCheckoutHandler\nvoid processPrecheckOut(BotContext context, PreCheckoutQuery query){\n    // Always confirm the checkout for this demo.\n    // In a real application, add your validation logic here and answer false if it fails.\n    context.answerPreCheckoutQuery(query.id, true).exec();\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>PreCheckoutQuery</code> object contains all details about the impending payment.</li> <li>Calling <code>answerPreCheckoutQuery</code> with <code>true</code> tells Telegram the payment is authorized to be completed by the user.</li> <li>Calling it with <code>false</code> and an optional error message would decline the payment and inform the user.</li> </ul> <p>Handle Successful Payment</p> <p>Once the Precheckout query is answered successfully and the user completes the payment, Telegram sends an <code>Update</code> containing a <code>Message</code> with a <code>successful_payment</code> field.</p> <p>In a real application, this is where you would:</p> <ul> <li>Grant the user access to the purchased product or service.</li> <li>Generate and send a license key.</li> <li>Update your database to record the transaction.</li> <li>Fulfill the order.</li> </ul> <p>For this demonstration, we immediately refund the payment.</p> MethodAnnotation <pre><code>static void acceptPayment(BotContext context, Message message){\n    // Extract the payment details from the message\n    var payment = message.successful_payment;\n\n    // REFUND THE PAYMENT (DEMONSTRATION ONLY)\n    // This showcases the refundStars method.\n    // In a real application, you would NOT do this; you would deliver the product instead.\n    context.refundStarPayment(message.from.id, payment.telegram_payment_charge_id).exec();\n\n    // Inform the user that their payment was received and immediately refunded\n    context.sendMessage(message.chat.id,\n            \"&lt;b&gt;Yay, your money is refunded.&lt;/b&gt;\\n\\n\" +\n            \"&lt;i&gt;Thanks for your generous donation&lt;/i&gt;\"\n    ).parseMode(ParseMode.HTML).exec();\n}\n</code></pre> <pre><code>// Add in main method:\nbot.onMessage(filter -&gt; filter.successfulPayment(), PaymentExampleBot::acceptPayment);\n</code></pre> <pre><code>@MessageHandler(type = MessageType.SUCCESSFUL_PAYMENT)\nvoid acceptPayment(BotContext context, Message message){\n    // Extract the payment details from the message\n    var payment = message.successful_payment;\n\n    // REFUND THE PAYMENT (DEMONSTRATION ONLY)\n    // This showcases the refundStars method.\n    // In a real application, you would NOT do this; you would deliver the product instead.\n    context.refundStarPayment(message.from.id, payment.telegram_payment_charge_id).exec();\n\n    // Inform the user that their payment was received and immediately refunded\n    context.sendMessage(message.chat.id,\n            \"&lt;b&gt;Yay, your money is refunded.&lt;/b&gt;\\n\\n\" +\n            \"&lt;i&gt;Thanks for your generous donation&lt;/i&gt;\"\n    ).parseMode(ParseMode.HTML).exec();\n}\n</code></pre> <p>Important Note: The <code>refundStarPayment</code> call is for demonstration purposes only. A real bot would not charge users and then instantly refund them. This method is useful for handling legitimate refund requests or errors.</p> <p>Final Setup and Execution</p> <p>All handlers are registered in the <code>main</code> method, and the bot is started using Long Polling.</p> MethodAnnotation <pre><code>public static void main(String[] args){\n// Initialize the bot client with the token from an environment variable\n    final var bot = new BotClient(TOKEN);\n\n    // Register command handlers\n    bot.onMessage(filter -&gt; filter.commands(\"start\"), PaymentExampleBot::start);\n    bot.onMessage(filter -&gt; filter.commands(\"pay\"), PaymentExampleBot::pay);\n\n    // Register payment handlers\n    bot.onPreCheckout(filter -&gt; true, PaymentExampleBot::processPrecheckOut);\n    bot.onMessage(filter -&gt; filter.successfulPayment(), PaymentExampleBot::acceptPayment);\n\n    // Start the bot\n    bot.startPolling();\n}\n</code></pre> <pre><code>public class PaymentExampleBot {\n    static String TOKEN = System.getenv(\"TOKEN\");\n\n    public static void main(String[] args){\n        BotClient bot = new BotClient(TOKEN);\n        bot.addHandler(new PaymentExampleBot());\n        bot.startPolling();\n    }\n\n    @MessageHandler(commands = \"start\")\n    void start(BotContext context, Message message){ /* ... */ }\n\n    @MessageHandler(commands = \"pay\")\n    void pay(BotContext context, Message message){ /* ... */ }\n\n    @PreCheckoutHandler\n    void processPrecheckOut(BotContext context, PreCheckoutQuery query){ /* ... */ }\n\n    @MessageHandler(type = MessageType.SUCCESSFUL_PAYMENT)\n    void acceptPayment(BotContext context, Message message){ /* ... */ }\n}\n</code></pre> <p></p> <p>The full source code can be found on examples/payment_bot</p>"},{"location":"examples/state_bot/","title":"State Management Example Bot","text":"<p>In this example section, we will create a bot that demonstrates Telegram's state management system. The bot will guide users through a multi-step conversation to collect their name and age, using states to maintain context between interactions.</p> <p>We will use the following handlers:</p> <ul> <li><code>onMessage</code> with <code>filter.commands()</code> or <code>@MessageHandler</code> with <code>command</code> parameter for command triggers </li> <li><code>onMessage</code> with <code>filter.state()</code> or <code>@MessageHandler</code> with <code>state</code> parameter for state-specific message handling</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.updates.Message;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.enums.MessageType;\nimport io.github.natanimn.telebof.annotations.MessageHandler;\nimport io.github.natanimn.telebof.types.updates.Message;\n</code></pre> <p>Create <code>StateExampleBot</code> class and initialize <code>BotClient</code> with state handlers</p> MethodAnnotation <pre><code>public class StateExampleBot {\n\n    BotClient bot;\n\n    public StateExampleBot(String token){\n        bot = new BotClient(token);\n\n        // Register handlers for different states and commands\n        bot.onMessage(filter -&gt; filter.commands(\"start\"), this::start);\n        bot.onMessage(filter -&gt; filter.commands(\"cancel\") &amp;&amp; filter.state(\"*\"), this::cancel);\n        bot.onMessage(filter -&gt; filter.state(\"name\") &amp;&amp; filter.text(), this::getName);\n        bot.onMessage(filter -&gt; filter.state(\"age\") &amp;&amp; filter.text(), this::getAge);\n    }\n}\n</code></pre> <pre><code>public class StateExampleBot {\n\n    BotClient bot;\n\n    public StateExampleBot(String token){\n        bot = new BotClient(token);\n        bot.addHandler(this);\n    }\n}\n</code></pre> <p>Our bot will manage the following conversation flow using states:</p> <ol> <li>/start command \u2192 Sets state to <code>\"name\"</code> and asks for user's name</li> <li>User provides name \u2192 Sets state to <code>\"age\"</code> and asks for age</li> <li>User provides age \u2192 Processes both pieces of information and clears state</li> <li>/cancel command \u2192 Clears current state at any point in the conversation</li> </ol>"},{"location":"examples/state_bot/#state-handlers-implementation","title":"State Handlers Implementation","text":""},{"location":"examples/state_bot/#1-start-handler-initiating-the-conversation","title":"1. Start Handler - Initiating the Conversation","text":"<p>The <code>/start</code> command begins the multi-step interaction by setting the initial state.</p> MethodAnnotation <pre><code>private void start(BotContext ctx, Message message){\n    // Ask for the user's name\n    ctx.sendMessage(message.from.id, \"Hey! What is your name?\").exec();\n\n    // Set the user's state to \"name\" to indicate we're expecting their name next\n    ctx.setState(message.from.id, \"name\");\n}\n</code></pre> <pre><code>@MessageHandler(commands = \"start\")\nprivate void start(BotContext ctx, Message message){\n    // Ask for the user's name\n    ctx.sendMessage(message.from.id, \"Hey! What is your name?\").exec();\n\n    // Set the user's state to \"name\" to indicate we're expecting their name next\n    ctx.setState(message.from.id, \"name\");\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>setState(user_id, \"name\")</code> marks that this user is now in the \"name\" state</li> <li>The next message from this user will be processed by the <code>getName</code> handler</li> </ul>"},{"location":"examples/state_bot/#2-name-handler-collecting-the-name","title":"2. Name Handler - Collecting the Name","text":"<p>This handler is triggered when a user in the <code>\"name\"</code> state sends any message.</p> MethodAnnotation <p><pre><code>private void getName(BotContext ctx, Message message){\n    // Ask for the user's age\n    ctx.sendMessage(message.from.id, \"How old are you?\").exec();\n\n    // Transition to the \"age\" state\n    ctx.setState(message.from.id, \"age\");\n\n    // Store the provided name in state data for later use\n    var data = ctx.getStateData(message.from.id);\n    data.put(\"name\", message.text);\n}\n</code></pre> Key Concepts:</p> <ul> <li><code>filter.state(\"name\")</code> ensures this handler only processes messages from users in the \"name\" state</li> <li><code>filter.text()</code> ensures that user only enter <code>text</code></li> <li><code>getStateData(user_id)</code> retrieves a Map where we can store temporary conversation data</li> <li><code>data.put(\"name\", message.text)</code> saves the user's name for the final summary</li> </ul> <pre><code>@MessageHandler(type = MessageType.TEXT, state = \"name\")\nprivate void getName(BotContext ctx, Message message){\n    // Ask for the user's age\n    ctx.sendMessage(message.from.id, \"How old are you?\").exec();\n\n    // Transition to the \"age\" state\n    ctx.setState(message.from.id, \"age\");\n\n    // Store the provided name in state data for later use\n    var data = ctx.getStateData(message.from.id);\n    data.put(\"name\", message.text);\n}\n</code></pre> <p>Key Concepts:</p> <ul> <li><code>state = \"name\"</code> ensures this handler only processes messages from users in the \"name\" state</li> <li><code>type = MessageType.TEXT</code> ensures that user only enter <code>text</code></li> <li><code>getStateData(user_id)</code> retrieves a Map where we can store temporary conversation data</li> <li><code>data.put(\"name\", message.text)</code> saves the user's name for the final summary</li> </ul>"},{"location":"examples/state_bot/#3-age-handler-collecting-and-processing-age","title":"3. Age Handler - Collecting and Processing Age","text":"<p>This handler processes messages from users in the <code>\"age\"</code> state.</p> MethodAnnotation <pre><code>private void getAge(BotContext ctx, Message message){\n    int age;\n\n    // Validate that the input is a number\n    try {\n        age = Integer.parseInt(message.text);\n    } catch (NumberFormatException e) {\n        ctx.sendMessage(message.from.id, \"Please enter a valid number\").exec();\n        return; // Stay in the \"age\" state until valid input is provided\n    }\n\n    // Retrieve the stored name from state data\n    var data = ctx.getStateData(message.from.id);\n\n    // Send confirmation message\n    ctx.sendMessage(message.from.id, \"Thank you for the information you have provided.\").exec();\n\n    // Display the collected information\n    ctx.sendMessage(message.from.id, \n            String.format(\"&lt;b&gt;Name:&lt;/b&gt; %s\\n&lt;b&gt;Age:&lt;/b&gt; %d\", data.get(\"name\"), age))\n            .parseMode(ParseMode.HTML)\n            .exec();\n\n    // The state is automatically cleared after the conversation completes\n    ctx.clearState(message.from.id);\n}\n</code></pre> <pre><code>@MessageHandler(state = \"age\", type = MessageType.TEXT)\nprivate void getAge(BotContext ctx, Message message){\n    int age;\n\n    // Validate that the input is a number\n    try {\n        age = Integer.parseInt(message.text);\n    } catch (NumberFormatException e) {\n        ctx.sendMessage(message.from.id, \"Please enter a valid number\").exec();\n        return; // Stay in the \"age\" state until valid input is provided\n    }\n\n    // Retrieve the stored name from state data\n    var data = ctx.getStateData(message.from.id);\n\n    // Send confirmation message\n    ctx.sendMessage(message.from.id, \"Thank you for the information you have provided.\").exec();\n\n    // Display the collected information\n    ctx.sendMessage(message.from.id, \n            String.format(\"&lt;b&gt;Name:&lt;/b&gt; %s\\n&lt;b&gt;Age:&lt;/b&gt; %d\", data.get(\"name\"), age))\n            .parseMode(ParseMode.HTML)\n            .exec();\n\n    // The state is automatically cleared after the conversation completes\n    ctx.clearState(message.from.id);\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Input validation ensures we get a valid age before proceeding</li> <li><code>data.get(\"name\")</code> retrieves the name stored in the previous step</li> <li>The state is automatically handled by the framework after completion</li> </ul>"},{"location":"examples/state_bot/#4-cancel-handler-aborting-the-conversation","title":"4. Cancel Handler - Aborting the Conversation","text":"<p>The <code>/cancel</code> command can be used at any point to abort the current conversation.</p> MethodMethod <pre><code>private void cancel(BotContext ctx, Message message){\n    // Clear the user's current state and any stored data\n    ctx.clearState(message.from.id);\n\n    ctx.sendMessage(message.from.id, \n            \"Your information has been cleared. Type /start to begin again.\").exec();\n}\n</code></pre> <p>Key Feature:</p> <ul> <li><code>filter.state(\"*\")</code> matches users in any active state, allowing cancellation from any step</li> <li><code>clearState(user_id)</code> removes both the state marker and any associated data</li> </ul> <p><pre><code>@MessageHandler(commands = \"cancel\", state = \"*\", priority = -1)\nprivate void cancel(BotContext ctx, Message message){\n    // Clear the user's current state and any stored data\n    ctx.clearState(message.from.id);\n        ctx.sendMessage(message.from.id, \n        \"Your information has been cleared. Type /start to begin again.\"\n    ).exec();\n}\n</code></pre> Key Feature:</p> <ul> <li><code>state = \"*\"</code> matches users in any active state, allowing cancellation from any step</li> <li><code>priority = -1</code> registered and executed before all handlers </li> <li><code>clearState(user_id)</code> removes both the state marker and any associated data</li> </ul> <p></p>"},{"location":"examples/state_bot/#running-the-bot","title":"Running the Bot","text":"<pre><code>public void run(){\n    bot.startPolling();\n}\n\npublic static void main(String[] args){\n    var token = System.getenv(\"TOKEN\"); // Get token from environment variable\n    var state_bot = new StateExampleBot(token);\n    state_bot.run();\n}\n</code></pre>"},{"location":"examples/state_bot/#conversation-flow-example","title":"Conversation Flow Example","text":"<ol> <li>User sends <code>/start</code> \u2192 Bot sets state to <code>\"name\"</code> and asks for name</li> <li>User provides name \u2192 Bot stores name, sets state to <code>\"age\"</code>, asks for age</li> <li>User provides age \u2192 Bot displays collected information</li> <li>(Optional) User can send <code>/cancel</code> at any time to abort the process</li> </ol> <p>The full source code can be found on examples/state_bot</p>"},{"location":"examples/webhook_spring/","title":"Spring Boot Webhook Bot","text":"<p>This example demonstrates how to integrate a Telebof bot with Spring Boot using webhooks instead of long polling. Webhooks provide a more efficient and scalable approach for production environments by having Telegram push updates to your server.</p> <p>This implementation shows:</p> <ul> <li>Spring Boot integration with Telebof</li> <li>Webhook configuration instead of long polling</li> <li>REST controller for receiving updates</li> <li>Basic echo bot functionality</li> </ul> <p>Project Structure and Dependencies</p> <p>First, ensure you have the necessary Spring Boot dependencies in your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;version&gt;LATEST_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.github.natanimn&lt;/groupId&gt;\n        &lt;artifactId&gt;telebof&lt;/artifactId&gt;\n        &lt;version&gt;LATEST_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Main Application Class</p> <pre><code>package io.github.natanimn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class WebhookBot {\n    public static void main(String[] args) {\n        SpringApplication.run(WebhookBot.class, args);\n    }\n}\n</code></pre> <p>Webhook Controller Class</p> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.log.BotLog;\nimport io.github.natanimn.telebof.filters.Filter;\nimport io.github.natanimn.telebof.types.updates.Update;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\nimport java.util.logging.Level;\n\n@RestController\nclass WebhookController {\n\n    private final BotClient bot;\n    private final String TOKEN = \"BOT_TOKEN\"; // Replace with your actual token\n    private final String URL = \"https://your-domain.com\"; // Replace with your actual domain\n\n    public WebhookController() {\n        // Set logging level\n        BotLog.setLevel(Level.INFO);\n\n        // Initialize bot client\n        this.bot = new BotClient(TOKEN);\n\n        // Clean up any existing webhook\n        bot.context.deleteWebhook();\n\n        // Set new webhook URL\n        bot.context.setWebhook(String.format(\"%s/webhook\", URL)).exec();\n\n        // Add message handlers\n        bot.onMessage(filter -&gt; filter.commands(\"start\"), (ctx, message) -&gt; {\n            ctx.sendMessage(message.getChat().getId(), \"Hello, I am Spring Boot echo bot\").exec();\n        });\n\n        bot.onMessage(Filter::text, (ctx, message) -&gt; {\n            ctx.sendMessage(message.getChat().getId(), message.getText()).exec();\n        });\n    }\n\n    /**\n     * Webhook endpoint that receives updates from Telegram\n     * @param updates List of updates sent by Telegram\n     * @return \"OK\" response to acknowledge receipt\n     */\n    @PostMapping(\"/webhook\")\n    public String getUpdates(@RequestBody List&lt;Update&gt; updates) {\n        // Process incoming updates\n        bot.processUpdates(updates);\n        return \"OK\";\n    }\n}\n</code></pre>"},{"location":"examples/webhook_spring/#key-components-explained","title":"Key Components Explained","text":""},{"location":"examples/webhook_spring/#1-spring-boot-configuration","title":"1. Spring Boot Configuration","text":"<pre><code>@SpringBootApplication\npublic class WebhookBot {\n    public static void main(String[] args) {\n        SpringApplication.run(WebhookBot.class, args);\n    }\n}\n</code></pre> <ul> <li><code>@SpringBootApplication</code> enables auto-configuration and component scanning</li> <li>Main method starts the embedded Tomcat server</li> </ul>"},{"location":"examples/webhook_spring/#2-webhook-setup","title":"2. Webhook Setup","text":"<pre><code>bot.context.deleteWebhook();\nbot.context.setWebhook(String.format(\"%s/webhook\", URL)).exec();\n</code></pre> <ul> <li>deleteWebhook(): Removes any existing webhook configuration</li> <li>setWebhook(): Configures Telegram to send updates to your server URL</li> </ul>"},{"location":"examples/webhook_spring/#3-rest-controller","title":"3. REST Controller","text":"<pre><code>@RestController\nclass WebhookController {\n    @PostMapping(\"/webhook\")\n    public String getUpdates(@RequestBody List&lt;Update&gt; updates) {\n        bot.processUpdates(updates);\n        return \"OK\";\n    }\n}\n</code></pre> <ul> <li><code>@RestController</code> marks the class as a web request handler</li> <li><code>@PostMapping(\"/webhook\")</code> maps POST requests to the /webhook endpoint</li> <li><code>@RequestBody</code> captures the JSON payload from Telegram</li> <li>Returns \"OK\" to acknowledge successful receipt of updates</li> </ul>"},{"location":"examples/webhook_spring/#4-bot-handlers","title":"4. Bot Handlers","text":"<pre><code>bot.onMessage(filter -&gt; filter.commands(\"start\"), (ctx, message) -&gt; {\n    ctx.sendMessage(message.getChat().getId(), \"Hello, I am Spring Boot echo bot\").exec();\n});\n\nbot.onMessage(Filter::text, (ctx, message) -&gt; {\n    ctx.sendMessage(message.getChat().getId(), message.getText()).exec();\n});\n</code></pre> <ul> <li>Start command handler: Responds to /start command</li> <li>Text message handler: Echoes any text message back to the user</li> </ul>"},{"location":"examples/webhook_spring/#configuration-requirements","title":"Configuration Requirements","text":"<p>Webhooks require HTTPS in production:</p> <ul> <li>Obtain SSL certificate for your domain</li> <li>Configure Spring Boot for HTTPS</li> <li>Ensure your domain is accessible publicly</li> </ul> <p>The full source code can be found on examples/webhook_bot</p>"},{"location":"examples/welcome_bot/","title":"Welcome Bot","text":"<p>In this example, we will create a bot that sends welcome messages to new members, handles its own promotions, deletes \"member left\" messages, and provides an invite button for groups.</p> <p>We will use two different types of handler:</p> <ul> <li><code>onMessage</code> or <code>@MessageHandler</code> for handling command and service messages(i.e new chat member and left chat member)</li> <li><code>onMyChatMember</code> for handling updates about the bot's own member status in a chat (e.g., promoted, demoted, removed).</li> </ul> <p>Import necessary classes</p> MethodAnnotation <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ChatMemberStatus;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\nimport io.github.natanimn.telebof.types.updates.ChatMemberUpdated;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport java.util.Objects;\n</code></pre> <pre><code>package io.github.natanimn;\n\nimport io.github.natanimn.telebof.BotClient;\nimport io.github.natanimn.telebof.BotContext;\nimport io.github.natanimn.telebof.enums.ChatMemberStatus;\nimport io.github.natanimn.telebof.enums.ParseMode;\nimport io.github.natanimn.telebof.enums.ChatMemberStatus;\nimport io.github.natanimn.telebof.enums.MessageType;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardButton;\nimport io.github.natanimn.telebof.types.keyboard.InlineKeyboardMarkup;\nimport io.github.natanimn.telebof.types.updates.ChatMemberUpdated;\nimport io.github.natanimn.telebof.types.updates.Message;\nimport io.github.natanimn.telebof.types.annotations.MessageHandler;\nimport io.github.natanimn.telebof.types.annotations.MyChatMemberHandler;\nimport java.util.Objects;\n</code></pre> <p>Let us create <code>WelcomeBot</code> class with a constructor and initialize <code>BotClient</code> with a <code>token</code></p> MethodAnnotation <pre><code>public class WelcomeBot {\n\n    final BotClient bot;\n    public WelcomeBot(String token){\n        this.bot = new BotClient(token);\n    }\n}\n</code></pre> <pre><code>public class WelcomeBot {\n\n    final BotClient bot;\n    public WelcomeBot(String token){\n        this.bot = new BotClient(token);\n        bot.addHandler(this);\n    }\n}\n</code></pre> <p>Our bot will be handling the following events:</p> <ul> <li><code>/start</code> command in private chat  </li> <li>New chat member joins  </li> <li>Bot promotion in group  </li> <li>Left chat member </li> </ul> <p>Create <code>/start</code> handler and show invite button</p> <p>When the user types <code>/start</code> in a private chat, the bot responds with an inline button to invite the bot into a group with the <code>delete_messages</code> admin right pre selected.</p> MethodAnnotation <pre><code>private void startPrivate(BotContext context, Message message){\n    var keyboard     = new InlineKeyboardMarkup();\n    var botUsername  = bot.context.getMe().exec().getUsername();\n\n    var url = String.format(\"https://t.me/%s?startgroup&amp;admin=delete_messages\", botUsername);\n\n    keyboard.addKeyboard(new InlineKeyboardButton(\"Add me to your group\").url(url));\n    var text = \"\"\"\n                &lt;b&gt;\\uD83D\\uDC4B Hi, I am Welcome bot&lt;/b&gt;\n\n                Add me to your group, and I will send welcome message to new members\"\"\";\n\n    context.sendMessage(message.getChat().getId(), text)\n            .parseMode(ParseMode.HTML)\n            .replyMarkup(keyboard)\n            .exec();\n}\n</code></pre> <p>Add the handler inside the constructor <pre><code>bot.onMessage(filter -&gt; filter.commands(\"start\") &amp;&amp; filter.Private(), this::startPrivate);\n</code></pre></p> <pre><code>@MessageHandler(commands = \"start\", chatType = ChatType.PRIVATE)\nprivate void startPrivate(BotContext context, Message message){\n    var keyboard     = new InlineKeyboardMarkup();\n    var botUsername  = bot.context.getMe().exec().getUsername();\n\n    var url = String.format(\"https://t.me/%s?startgroup&amp;admin=delete_messages\", botUsername);\n\n    keyboard.addKeyboard(new InlineKeyboardButton(\"Add me to your group\").url(url));\n    var text = \"\"\"\n                &lt;b&gt;\\uD83D\\uDC4B Hi, I am Welcome bot&lt;/b&gt;\n\n                Add me to your group, and I will send welcome message to new members\"\"\";\n\n    context.sendMessage(message.getChat().getId(), text)\n            .parseMode(ParseMode.HTML)\n            .replyMarkup(keyboard)\n            .exec();\n}\n</code></pre> <p></p> <p>Handle bot promotion and demotion</p> <p>The <code>onMyChatMember</code> or <code>@MyChatMemeberHandler</code> handler triggers when the bot's member status changes in a chat (e.g., promoted to admin, demoted to member, kicked, or left). Sometimes the bot is promoted to admin in group, removed from group, left from group or dissmissed from admin  in groups.  </p> <ul> <li>This handler ensures the bot leaves any group where it is not an administrator with the Delete Messages permission.</li> </ul> MethodAnnotation <pre><code>private void botPromoted(BotContext context, ChatMemberUpdated member){\n    // 1. Get the new status of the bot\n    ChatMemberStatus newStatus = member.getNewChatMember().getStatus();\n\n    // 2. Ignore updates where the bot is leaving or being kicked/banned.\n    // Handling those would cause errors as the bot can't send messages or leave a chat it's already been removed from.\n    if (newStatus == ChatMemberStatus.LEFT || newStatus == ChatMemberStatus.BANNED) {\n        return;\n    }\n\n    // 3. Check if the bot is NOT an admin OR is an admin but CANNOT delete messages\n    boolean isAdminWithDeletePerms = (newStatus == ChatMemberStatus.ADMINISTRATOR \n                                      &amp;&amp; member.getNewChatMember().getCanDeleteMessages() == true);\n\n    if (!isAdminWithDeletePerms) {\n        try {\n            context.sendMessage(\n                member.getChat().getId(),\n                \"&lt;b&gt;Sorry, I cannot stay in this group without having &lt;i&gt;Delete message&lt;/i&gt; permission.&lt;/b&gt;\")\n                .parseMode(ParseMode.HTML)\n                .exec();\n        } catch (Exception e) {\n            // Ignore errors if sending the message fails (e.g., in restricted groups)\n        } finally {\n            context.leaveChat(member.getChat().getId()).exec();\n        }\n    } else {\n        // The bot was promoted to admin WITH delete permissions\n        context.sendMessage(member.getChat().getId(), \"Thank you for promoting me in this group!\").exec();\n    }\n\n}\n</code></pre> <p>Add the handler inside the constructor <pre><code>bot.onMyChatMember(_ -&gt; true, this::botPromoted);\n</code></pre></p> <pre><code>@MyChatMemberHandler(status = ChatMemberStatus.ADMINISTRATOR)\nvoid botPromoted(BotContext context, ChatMemberUpdated member){\n    if (member.getNewChatMember().getCanDeleteMessages() == true)\n        context.sendMessage(memberUpdated.getChat().getId(), \"Thank you for promoting me in this group!\").exec();\n    else {\n        context.sendMessage(\n                memberUpdated.getChat().getId(),\n                \"&lt;b&gt;Sorry, I cannot stay in this group without having &lt;i&gt;Delete message&lt;/i&gt; permission.&lt;/b&gt;\"\n        ).parseMode(ParseMode.HTML).exec();\n        context.leaveChat(member.getChat().getId()).exec();\n    }\n}\n\n@MyChatMemberHandler(status = ChatMemberStatus.MEMBER)\nvoid botDemoted(BotContext context, ChatMemberUpdated member){\n    context.leaveChat(member.getChat().getId()).exec();\n}\n</code></pre> <p></p> <p>Send welcome message when a new member joins</p> <p>This handler checks when a new member joins the group:  </p> <ul> <li>Deletes joining messages</li> <li>If the member is the bot itself \u2192 ignores  </li> <li>If it is a normal user \u2192 send a welcome message  </li> </ul> MethodAnnotation <pre><code>private void sendWelcomeMessage(BotContext context, Message message){\n    context.deleteMessage(chatId, message.getMessageId()).exec();\n\n    var chatId = message.getChat().getId();\n    var botId  = bot.context.getMe().exec().getId();\n\n    for (var member: message.getNewChatMembers()){\n        if (Objects.equals(botId, member.getId())) continue;\n\n        else {\n            context.sendMessage(message.getChat().getId(), String.format(\"\ud83c\udf3c &lt;b&gt;Hey %s!&lt;/b&gt;\\n\\n&lt;b&gt;Welcome to this group.&lt;/b&gt;\", member.mention()))\n                .parseMode(ParseMode.HTML)\n                .exec();\n        }\n    }\n}\n</code></pre> <pre><code>@MessageHandler(type = MessageType.NEW_CHAT_MEMBER)\nprivate void sendWelcomeMessage(BotContext context, Message message){\n    context.deleteMessage(chatId, message.getMessageId()).exec();\n\n    var chatId = message.getChat().getId();\n    var botId  = bot.context.getMe().exec().getId();\n\n    for (var member: message.getNewChatMembers()){\n        if (Objects.equals(botId, member.getId())) continue;\n        else {\n            context.sendMessage(message.getChat().getId(), String.format(\"\ud83c\udf3c &lt;b&gt;Hey %s!&lt;/b&gt;\\n\\n&lt;b&gt;Welcome to this group.&lt;/b&gt;\", member.mention()))\n                    .parseMode(ParseMode.HTML)\n                    .exec();\n        }\n    }\n}\n</code></pre> <p>Delete left member messages</p> <p>This handler simply deletes the service message that is generated when a member leaves the chat.</p> MethodAnnotation <pre><code>private void deleteLeftMessage(BotContext context, Message message){\n    context.deleteMessage(chatId, message.getMessageId()).exec();\n}\n</code></pre> <pre><code>@MessageHandler(type = MessageType.LEFT_CHAT_MEMBER)\nprivate void deleteLeftMessage(BotContext context, Message message){\n    context.deleteMessage(chatId, message.getMessageId()).exec();\n}\n</code></pre> <p>Create a Custom Filter for Admin Permissions (For method handler) </p> <p>Before adding the service message handlers, we need a filter to ensure the bot only tries to delete messages if it actually has the permission to do so. We create a CustomFilter to check the bot's admin status.</p> <pre><code>class BotIsAdmin implements CustomFilter{\n    BotClient client;\n\n    public BotIsAdmin(BotClient client){\n        this.client = client;\n    }\n\n    class BotIsAdmin implements CustomFilter {\n    BotClient client;\n\n    public BotIsAdmin(BotClient client){\n        this.client = client;\n    }\n\n    @Override\n    public boolean check(Update update) {\n        var botId  = bot.context.getMe().exec().getId();\n        try {\n            // Get the bot's chat member information\n            var member = client.context.getChatMember(update.message.getChat().getId(), botId).exec();\n            // Check if the bot is an administrator and has the 'can_delete_messages' right\n            return (member.getStatus() == ChatMemberStatus.ADMINISTRATOR \n                    &amp;&amp; member.getCanDeleteMessages() == true);\n        } catch (Exception e) {\n            // If an error occurs (e.g., bot is not in chat, API error), return false\n            return false;\n        }\n    }\n}   \n</code></pre> <p>Explanation:</p> <p>This filter safely checks if the bot is an administrator with delete permissions in the chat where the <code>service message</code> originated. The try/catch ensures the bot doesn't crash if it can't get this information.</p> <p>Now, create an instance of this filter and add it to the handlers in the main constructor.</p> <p>Our final handlers in the constructor:</p> Method <pre><code>public WelcomeBot(String token){\n    this.bot = new BotClient(token);\n    var botIsAdmin = new BotIsAdmin(bot); // Create the custom filter\n\n    bot.onMessage(filter -&gt; filter.commands(\"start\") &amp;&amp; filter.Private(), this::startPrivate);\n    bot.onMyChatMember(_ -&gt; true, this::botPromoted);\n\n    // Only handle new/left members if the bot is an admin with delete permissions\n    bot.onMessage(filter -&gt; filter.newChatMember() &amp;&amp; filter.customFilter(botIsAdmin), this::sendWelcomeMessage);\n    bot.onMessage(filter -&gt; filter.leftChatMember() &amp;&amp; filter.customFilter(botIsAdmin), this::deleteLeftMessage);\n}\n</code></pre> <p>Finally, create <code>runBot</code> method and run the bot on long polling</p> <pre><code>public void runBot(){\n    bot.startPolling();\n}\n\npublic static void main(String[] args){\n    final var TOKEN = \"BOT_TOKEN\";\n    final var welcomeBot = new WelcomeBot(TOKEN);\n    welcomeBot.runBot();\n}\n</code></pre> <p>Summary</p> <p>Our bot can:</p> <ul> <li>Respond to <code>/start</code> in private chats with an invite button.</li> <li>Automatically leave any group where it is not an administrator with the Delete Messages permission.</li> <li>Send a welcome message when a new member joins.</li> <li>Delete the service messages for both new members and left members.</li> </ul> <p>The full source code can be found on examples/welcome_bot</p>"}]}